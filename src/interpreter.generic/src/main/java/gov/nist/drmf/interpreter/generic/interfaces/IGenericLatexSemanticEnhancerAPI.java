package gov.nist.drmf.interpreter.generic.interfaces;

import gov.nist.drmf.interpreter.common.pojo.CASResult;
import gov.nist.drmf.interpreter.common.pojo.ComputationTask;
import gov.nist.drmf.interpreter.common.exceptions.MinimumRequirementNotFulfilledException;
import gov.nist.drmf.interpreter.generic.mlp.pojo.MOIPresentations;
import gov.nist.drmf.interpreter.generic.mlp.pojo.SemanticEnhancedDocument;
import mlp.ParseException;

/**
 * This API represents the general tasks we need to achieve as described in
 * https://github.com/ag-gipp/LaCASt/issues/204.
 *
 * @author Andre Greiner-Petter
 */
public interface IGenericLatexSemanticEnhancerAPI {
    /**
     * Generates a full semantic and computed document based on the context. This is generally vey costly (depending
     * on the length of the given context and the number of math in it), so be careful using it.
     *
     * Essentially, it is the same as calling {@link #fullyEnhanceDocument(String)} followed by
     * {@link #appendCASComputationsToDocument(SemanticEnhancedDocument)} on the document.
     *
     * @param context the textual context to analyze
     * @return the full semantically enhanced and computed document
     */
    default SemanticEnhancedDocument computedFullDocument(String context) {
        SemanticEnhancedDocument sed = fullyEnhanceDocument(context);
        return appendCASComputationsToDocument(sed);
    }

    /**
     * Triggers the full-fledged semantic enhancement pipeline except for computing the results via CAS.
     * This is equivalent to calling {@link #generateAnnotatedDocument(String)} and
     * {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}.
     *
     * For adding CAS computation results to the semantic enhanced document you can call
     * {@link #appendCASComputationsToDocument(SemanticEnhancedDocument)} on the resulted document from this method.
     *
     * @param context the textual context to analyze
     * @return the full semantically enhanced document without computation results from CAS
     */
    default SemanticEnhancedDocument fullyEnhanceDocument(String context) {
        SemanticEnhancedDocument sed = generateAnnotatedDocument(context);
        return appendTranslationsToDocument(sed);
    }

    /**
     * The first step in the pipeline. Only generates a base representation of a semantically enhanced document.
     * It contains the full graph structure (including definition annotations) of the MOI in the given context.
     *
     * It does not contain translations yet. Neither to semantic LaTeX nor to any CAS representation. This will can
     * be added by calling {@link #appendTranslationsToDocument(SemanticEnhancedDocument)} on the result of this
     * method.
     *
     * @param context the context to analyze
     * @return a base version of a semantically annotated document essentially containing the entire dependency graph
     *          and including all definiens annotations but no translations to semantic LaTeX nor to any CAS.
     */
    SemanticEnhancedDocument generateAnnotatedDocument(String context);

    /**
     * Requires the base version of a semantic enhanced document generated by {@link #generateAnnotatedDocument(String)}.
     * Based on the dependency graph, this method will further fill-out the given annotated document with translations
     * to semantic LaTeX and to all CAS representations. It still does not contain any computation results yet though!
     * @param annotatedDocument base semantic document generated by {@link #generateAnnotatedDocument(String)}
     * @return the same object annotated with semantic latex and CAS translations
     */
    SemanticEnhancedDocument appendTranslationsToDocument(SemanticEnhancedDocument annotatedDocument)
            throws MinimumRequirementNotFulfilledException;

    /**
     * This requires a semantic document containing all translations to semantic LaTeX and CAS representations as
     * returned by {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}. It will trigger all computations
     * on every node in the document for every CAS. The final returned semantic document is fully-fledged and include
     * all computation results for all CAS.
     *
     * This is usually not advised because it may take a very long time to compute! It is better to compute results
     * for single variables though, such as via {@link #computeMOI(MOIPresentations)}.
     *
     * @param semanticDocument semantic document containing all translations to semantic LaTeX and CAS representations
     *                         as generated by {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}
     * @return fully-fledged document including CAS computation results
     */
    SemanticEnhancedDocument appendCASComputationsToDocument(SemanticEnhancedDocument semanticDocument)
            throws MinimumRequirementNotFulfilledException;

    /**
     * Generates an MOI representation for a single formula with the given context. This includes translations
     * to semantic LaTeX and CAS but no computations yet. In order to analyze the MOI via CAS you need to use one of the
     * computeMOI methods.
     * @param annotatedDocument annotated document as generated by {@link #generateAnnotatedDocument(String)}.
     * @param formula the formula to translate
     * @return MOI with semantic LaTeX and CAS representations
     */
    MOIPresentations generateMOIPresentationFromDocument(SemanticEnhancedDocument annotatedDocument, String formula)
            throws MinimumRequirementNotFulfilledException, ParseException;
    /**
     * Performs CAS computations on the MOI. The MOI must contain translations to semantic LaTeX and CAS already.
     * @param translatedMOI an MOI as generated by {@link #generateMOIPresentationFromDocument(SemanticEnhancedDocument, String)}
     *                      or as a single formula from {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}
     * @return MOI including the computed CAS results for the given MOI
     */
    MOIPresentations computeMOI(MOIPresentations translatedMOI);

    /**
     * Generate CAS results for the given translated MOI and specified CAS.
     * @param translatedMOI an MOI as generated by {@link #generateMOIPresentationFromDocument(SemanticEnhancedDocument, String)}
     *                      or as a single formula from {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}
     * @param cas the CAS to verify
     * @return CAS results for the given MOI and specified CAS
     */
    CASResult computeMOI(MOIPresentations translatedMOI, String cas);

    /**
     * Generate CAS results for the given translated MOI and specified CAS. It only performs the specified computation,
     * essentially symbolic or numeric computation task, but not both.
     * @param translatedMOI an MOI as generated by {@link #generateMOIPresentationFromDocument(SemanticEnhancedDocument, String)}
     *                      or as a single formula from {@link #appendTranslationsToDocument(SemanticEnhancedDocument)}
     * @param cas the CAS to verify
     * @return CAS results for the given MOI, specified CAS, and the computation task
     */
    CASResult computeMOI(MOIPresentations translatedMOI, String cas, ComputationTask task);
}
