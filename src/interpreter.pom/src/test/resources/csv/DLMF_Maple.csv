DLMF;Maple;Number of Variables;Slot of Differentiation;DLMF-Maple-Comment;Maple-Package;Maple-Alternatives
\sin@@{$0};sin($0);1;;;;
\cos@@{$0};cos($0);1;;;;
\tan@@{$0};tan($0);1;;;;
\sec@@{$0};sec($0);1;;;;
\csc@@{$0};csc($0);1;;;;
\cot@@{$0};cot($0);1;;;;
;;;;;;
\sinh@@{$0};sinh($0);1;;;;
\cosh@@{$0};cosh($0);1;;;;
\tanh@@{$0};tanh($0);1;;;;
\sech@@{$0};sech($0);1;;;;
\csch@@{$0};csch($0);1;;;;
\coth@@{$0};coth($0);1;;;;
;;;;;;
\asin@@{$0};arcsin($0);1;;;;
\acos@@{$0};arccos($0);1;;;;
\atan@@{$0};arctan($0);1;;;;
;;;;;;
\asec@@{$0};arcsec($0);1;;;;
\acsc@@{$0};arccsc($0);1;;;;
\acot@@{$0};arccot($0);1;;Maple defines another branch cut than DLMF for the invert cotangent function. You can use an alternative translation to avoid that. With the arctan alternative you have the same branch cuts as DLMF. See also 'According to Arbamowitz and Stegun or arccoth needn't be uncouth' by R.M. Corless, D.J. Jeffrey, S.M. Watt.;;arctan(1/($0)) || I/2*ln(($0-I)/($0+I) )
;;;;;;
\asinh@@{$0};arcsinh($0);1;;;;
\acosh@@{$0};arccosh($0);1;;;;
\atanh@@{$0};arctanh($0);1;;;;
\asech@@{$0};arcsech($0);1;;;;
\acsch@@{$0};arccsch($0);1;;;;
\acoth@@{$0};arccoth($0);1;;;;
;;;;;;
\FerrersP{\nu}@{x};LegendreP($0, $1);2;1;This translation is only correct, when you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to invoke forget(evalf) and forget(simplify), otherwise these functions never noticed the changes of _EnvLegendreCut.;;
X1:\FerrersPX\FerrersP[\mu]{\nu}@{x};LegendreP($1, $0, $2);3;1;This translation is only correct, when you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to invoke forget(evalf) and forget(simplify), otherwise these functions never noticed the changes of _EnvLegendreCut.;;
\FerrersQ{\nu}@{x};LegendreQ($0, $1);2;1;This translation is only correct, when you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to invoke forget(evalf) and forget(simplify), otherwise these functions never noticed the changes of _EnvLegendreCut.;;
X1:\FerrersQX\FerrersQ[\mu]{\nu}@{x};LegendreQ($1, $0, $2);3;1;This translation is only correct, when you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to invoke forget(evalf) and forget(simplify), otherwise these functions never noticed the changes of _EnvLegendreCut.;;
\assLegendreP{$0}@{$1};LegendreP($0, $1);2;1;If you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to reset it to -1..1 and invoke forget(evalf) and forget(simplify) to notify Maple about the changes.;;
X1:\assLegendrePX\assLegendreP[$1]{$0}@{$2};LegendreP($1, $0, $2);3;1;If you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to reset it to -1..1 and invoke forget(evalf) and forget(simplify) to notify Maple about the changes.;;
\assLegendreQ{$0}@{$1};LegendreQ($0, $1);2;1;If you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to reset it to -1..1 and invoke forget(evalf) and forget(simplify) to notify Maple about the changes.;;
X1:\assLegendreQX\assLegendreQ[$1]{$0}@{$2};LegendreQ($1, $0, $2);3;1;If you previously set Maple's internal variable _EnvLegendreCut := 1..infinity. You have to reset it to -1..1 and invoke forget(evalf) and forget(simplify) to notify Maple about the changes.;;
\assLegendreOlverQ{\nu}@{z};X2:LegendreQXLegendreQ($0,$1)/GAMMA($0+1);2;1;;;
X1:\assLegendreOlverQX\assLegendreOlverQ[\mu]{\nu}@{z};X3:LegendreQXexp(-($0)*Pi*I)*LegendreQ($1,$0,$2)/GAMMA($1+$0+1);3;1;;;
\DunsterQ{\tau}@{x};;2;1;;;
X1:\FerrersHatQX\DunsterQ[\mu]{\tau}@{x};;3;1;;;
;;;;;;
\npartitions{n};;;;Maple needs an extra package. Load it with the following command: with(combinat,partition);combinat,partition;nops(partition($0))
X1:\npartitionsX[k]@{n};;;;;;
