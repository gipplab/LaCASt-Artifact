%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DLMFfcns : Special Function Macros for DLMF project
% Autogenerated on 2010/09/23
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{DLMFfcns}[2010/09/23 Special Function Macros for DLMF]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some explanation of keywords:
% params: used to fill in 'demonstration' call of macro for documentation
% args:   ditto
% description: brief description of the function, hopefully enough to be unique.
%   It is used in a context like:
%    <demo_call> : <description>
%   so the display of the function need not be repeated within the description
%   unless it is needed for uniqueness.
% sortkey: <mainsymbol> <num-args> <num-scripts> <scripts>... <arg>... <lastresort>
%   where
%     <mainsymbol> latinized form the most significant symbol
%       use *<letters> to sort non alphabetic symbols
%       *m|, *n[, *p(, *q\{, *r<  for |, [,(,{,<   doubled for stacked arrangments
%     <num-args> number of apparent "arguments"
%     <num-scripts>  0 = none, 1=sub, 2=super, 3=both
%     <scripts>,<args> use z for scripts or arguments filled in with variables,
%         otherwise use literal;
%         use zz for "long" script or arg?
% Note: \operatorname is more appropriate for multiletter roman symbols that either
% take no arguments (as operators) or the arguments are sometimes un-parenthesized.
% \mathrm for other cases
% When you do use \operatorname, you'll likely want \! in front of parenthesized arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Special Function Definitions

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from Introduction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from Mathematical Introduction
\defSpecFun{Reals}{\mathbb{R}}[
  meaning=reals, role=ID, om=setname1:R,
  description={the set of real numbers},% $\Reals$},
  sortkey={R},
  ]{0}
\defSpecFun{Complexes}{\mathbb{C}}[
  meaning=complexes, role=ID, om=setname1:C,
  description={the set of complex numbers},% $\Complexes$},
  sortkey={C 0 0},
  ]{0}
\defSpecFun{natNumbers}{\mathbb{N}}[
  meaning=numbers, role=ID, om=setname1:N, % change meaning!!!
  description={the set of `natural' numbers (positive integers)},% $\natNumbers$},
  sortkey={N 0 0},
  ]{0}
\defSpecFun{Integers}{\mathbb{Z}}[
  meaning=integers, role=ID, om=setname1:Z,
  description={the set of integers},% $\Integers$},
  sortkey={Z 0 0},
  ]{0}
  %%% Never used except in signatures
  %%% Questionable notation, besides?
%%% % A bit controversial, but we need an unambiguous name, even
%%% % if the display will be debated...
%%% Note: \posIntegers  == \natNumbers (as used in DLMF!)
%%% Notatations used: Z^+ = N^*, or simply N
\defSpecFun{posIntegers}{{\mathbb{Z}^{+}}}[
  meaning=positive-integers, role=ID, % om=?_dlmf,
  description={the set of positive integers},% $\posIntegers$},
  sortkey={Z 0 2 +},
  ]{0}
%%% Notations used: N^0 = N_0, or simply N
\defSpecFun{nonnegIntegers}{{\mathbb{Z}^{*}}}[
  meaning=non-negative-integers, role=ID, % om=?_dlmf,
  description={the set of non-negative integers},% $\nonnegIntegers$},
  sortkey={Z 0 2 *},
  ]{0}
\defSpecFun{Rationals}{\mathbb{Q}}[
  meaning=rationals, role=ID, om=setname1:Q,
  description={the set of rational numbers},% $\Rationals$},
  sortkey={Q 0 0},
  ]{0}

%======================================================================
%%% Never used & dubious, besides
%%% \defSpecFun{Polynomials}{\mathbb{P}}[
%%%   meaning=polynomials, role=ID,% om=?_dlmf,
%%%   description={the set of polynomials},% $\Polynomials$},
%%%   sortkey={P 0 0},
%%%   ]{0}
%%% \defSpecFun{upperComplexes}{\mathbb{H}}[ % Upper half of complex plane
%%%   meaning=half-complex, role=ID, % om=?_dlmf,
%%%   description={the upper half of the complex plane},% $\upperComplexes$},
%%%   sortkey={H 0 0},
%%%   ]{0}
\defSpecFun{sign}{\operatorname{sign}}[%
   meaning=sign,role=OPFUNCTION, % om=?_dlmf,
   args={x},
   description={the sign of a number $x$},% $\sign$},
   sortkey={sign 1 0 z},
   ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{floor}[1]{\mleft\lfloor #1\mright\rfloor}[
  meaning=floor, om=rounding1:floor,
  params={x},
  description={the floor of a real number $x$},% $\floor{x}$},
  sortkey={*n[ 1 0 z floor},
  ]{0}
\defSpecFun{ceiling}[1]{\mleft\lceil#1\mright\rceil}[
  meaning=ceiling, om=rounding1:ceiling,
  params={x},
  description={the ceiling of a real number $x$},% $\ceiling{x}$},
  sortkey={*n[ 1 0 z ceil},
  ]{0}
\defSpecFun{Kroneckerdelta}[2]{\delta_{#1,#2}}[
  meaning=Kronecker, % om=?_dlmf,
  params={j}{k},
  description={the Kronecker delta},% $\Kroneckerdelta{j}{k}$},
  sortkey={delta 0 3 i j},
  ]{0}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 1 Algebraic and Analytic Methods
% q-Extensions to various combinatorics
% Don't use \binom, since we're GOING to rename \binom to \binom!
\defSpecFun{binom}[2]{\genfrac(){0pt}{}{#1}{#2}}[
  meaning=binomial, om=combinat1:binomial,
  description={the binomial coefficient},% $\binom{z}{m}$},
  params={z}{m},
  sortkey={*p(( 2 0 m n}, 
  ]{0}
\defSpecFun{multinomial}[2]{\genfrac(){0pt}{}{#1}{#2}}[
  meaning=multinomial, om=combinat1:multinomial,
  params={n}{n_1,n_2,\ldots,n_k},
  description={the multinomial coefficient},% $\multinomial{n}{n_1,n_2,\ldots,n_k}$},
  sortkey={*p(( 2 0 n n},
  ]{0}
\defSpecFun{Pochhammersym}[2]{{\mleft(#1\mright)_{#2}}}[ %Extra {} to inhibit breaks
  meaning=Pochhammer, om=hypergeo0:pochhammer,      % ?
  params={a}{n},
  description={the Pochhammer symbol (or shifted factorial)},% $\Pochhammersym{a}{n}$},
  sortkey={*p( 1 1 z z},
  ]{0}
\defSpecFun{shiftfactorial}[2]{{\mleft[#1\mright]_{#2}}}[
  meaning=shifted-factorial, % om=?_dlmf,
  params={a}{k},
  description={the partitional shifted factorial},% $\shiftfactorial{a}{k}$},
  sortkey={*n[ 1 1 z z},
  ]{0}
\defSpecFun{continuous}[1][]{C\ifx.#1.\else^{#1}\fi}[%
  meaning=set-of-continuous-functions-n-times-differentiable-on-interval, % om=?_dlmf,
  params={n}, args={(a,b)},
  description={the set of continuous functions $n$-times differentiable on the interval $(a,b)$},
%     $\continuous[n]{a,b}$},
  sortkey={C 1 2 z z},
  ]{1}[#1]
\defSpecFun{continuous[]}{C}[%
  meaning=set-of-continuous-functions, % om=?_dlmf,
  args={(a,b)},
  description={the set of functions continuous on the interval $(a,b)$},% $\continuous{a,b}$},
  sortkey={C 1 0 z},
  ]{1}[#1]
% special form for optional?
\defSpecFun{variation}[1][]{\mathcal{V}\ifx.#1.\else_{#1}\fi}[%
  meaning=variational-operator-on-interval, % om=?_dlmf,
  params={a,b}, args={f},
  description={the total variation of a function on an interval},% $\variation[a,b]$},
  sortkey={V 1 0 I},
  ]{1}
% NOTE: this macro is only used once w/o interval parameter: only to NAME the operator!
\defSpecFun{variation[]}{\mathcal{V}}[%
  meaning=variational-operator, % om=?_dlmf,
  args={f},
  description={the total variation of a function},% $\variation$},
  sortkey={V 1 0 I},
  ]{1}
% This should probably join with diff??? \diff@{x} ???
\defSpecFun{diffd}{\mathrm{d}}[
   meaning=differential-d, role=DIFFOP, % om=?_dlmf,
  description={the differential operator},% $\diffd$},
  sortkey={d 0 0},
  ]{0}
\defSpecFun{LeviCivitasym}[3]{\epsilon_{#1\InvisibleComma#2\InvisibleComma#3}}[
  meaning=Levi-Civita, om=combinat2_dlmf:Levi-Civita,
  params={i}{j}{k},
  description={the Levi-Civita symbol},% $\LeviCivitasym{i}{j}{k}$},
  sortkey={epsilon 0 1 zzz},
  ]{0}
\defSpecFun{dotprod}{\cdot}[
  meaning=dot-product, role=MULOP, om=linalg1:scalarproduct,
  description={the vector dot product operator},% $\dotprod$},
  sortkey={*a. 0 0},
 ]{0}
\defSpecFun{crossprod}{\times}[
  meaning=dot-product, role=MULOP, om=linalg1:vectorproduct,
  description={the vector cross product operator},% $\crossprod$},
  sortkey={*ax 0 0},
 ]{0}
\defSpecFun{divergence}{\operatorname{div}}[
  meaning=divergence, role=DIFFOP, om=veccalc1:divergence,
  description={the divergence operator},% $\divergence$},
  sortkey={div 0 0},
  ]{0}
\defSpecFun{curl}{\operatorname{curl}}[
  meaning=curl, role=DIFFOP, om=veccalc1:curl,
  description={the curl operator},% $\curl$},
  sortkey={curl 0 0},
  ]{0}
\defSpecFun{gradient}{\operatorname{grad}}[
  meaning=gradient, role=DIFFOP, om=veccalc1:grad,
  description={the gradient operator},% $\gradient$},
  sortkey={grad 0 0},
  ]{0}
\defSpecFun{transpose}[1]{#1^{\mathrm{T}}}[
  meaning=transpose, om=linalg1:transpose,
  params={\mathbf{X}},
  description={the transpose of a matrix},% $\transpose{\mathbf{X}}$},
  sortkey={T 1 0 z},
  ]{0}
\defSpecFun{trace}{\operatorname{tr}}[
  meaning=trace, role=LIMITOP, % om=?_dlmf,
  description={the trace of a matrix},% $\trace$},
  sortkey={tr 0 0},
  ]{0}
\defSpecFun{diag}{\operatorname{diag}}[
  meaning=diagonal, role=LIMITOP, % om=?_dlmf,
  description={the diagonal elements},% $\diag$},
  sortkey={diag 0 0},
  ]{0}
\defSpecFun{cartprod}{\times}[
  meaning=cartesian-product, role=MULOP, % om=linalg1:vectorproduct,
  description={the Cartesian product operator},% $\cartprod$},
  sortkey={*ax 0 0},
  ]{0}
\defSpecFun{setmod}{/}[
  meaning=set-modulus, role=MULOP, % om=?_dlmf,
  description={the set modulus operator},% $\setmod$},
  sortkey={*a/ 0 0},
 ]{0}
\defSpecFun{divides}{\mathbin{|}}[
  meaning=divides, role=MULOP, om=integer2:divides,
  description={the divides operator operator},% $\divides$},
  sortkey={*m| 0 0},
 ]{0}
\defSpecFun{abs}[1]{\mleft|#1\mright|}[
  meaning=absolute-value, om=arith1:abs,
  params={x},
  description={the absolute value of $x$},% $\abs{x}$},
  sortkey={*m| 1 0 z},
  ]{0}
\defSpecFun{phase}{\operatorname{ph}}[%
  meaning=phase,role=OPFUNCTION, om=complex1:argument,
  args={z},
  description={the phase of a complex number $z$},% $\phase$},
  sortkey={ph 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
%%% NOTE: This defines \realpart@@ & \realpart@@@{x} which would be more philosophically consistent.
%%% HOWEVER, it's a big change, since \realpart@@{x} is used throughout DLMF.
\defSpecFun{realpart}{\Re}[
  meaning=real-part, role=OPFUNCTION, om=complex1:real,
  args={z},
  description={the real part of a complex number $z$},% $\realpart@@$},
  sortkey={Re 1 0 z}
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{imagpart}{\Im}[
  meaning=imaginary-part, role=OPFUNCTION, om=complex1:imaginary,
  args={z},
  description={the imaginary part of a complex number $z$},% $\imagpart@@$},
  sortkey={Im 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{realpart@@}[1]{\Re {#1}}[
  meaning=real-part, role=OPFUNCTION, om=complex1:real, OBSOLETE=1,
  params={z},
  description={the real part of a complex number $z$},% $\realpart@@$},
  sortkey={Re 1 0 z}
  ]{0}
\defSpecFun{imagpart@@}[1]{\Im {#1}}[
  meaning=imaginary-part, role=OPFUNCTION, om=complex1:imaginary, OBSOLETE=1,
  params={z},
  description={the imaginary part of a complex number $z$},% $\imagpart@@$},
  sortkey={Im 1 0 z},
  ]{0}
\defSpecFun{conj}[1]{\overline{#1}}[
  meaning=conjugate, om=complex1:conjugate,
  params={z},
  description={the complex conjugate of a complex number $z$},% $\conj{z}$},
  sortkey={*a- 1 0 z},
  ]{0} % {1}[\mleft(#1\mright)][#1]
\defSpecFun{Wronskian}{\mathscr{W}}[%
   meaning=Wronskian, % om=?_dlmf,
   args={w_1,w_2},
   description={the Wronskian},% $\Wronskian$},
   sortkey={W 1 0 zz},
   ]{1}[\mleft\{#1\mright\}]

% These define the "Old" 2-arg transforms (awkward semantics & notation, both!)
% These should soon become obsolete.
% [NOTE: Remove neg space before parens for testing]
\defSpecFun{LaplaceTrans}{\mathscr{L}}[%
  meaning=Laplace-transform, OBSOLETE=1,
  args={f}{s},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{MellinTrans}{\mathscr{M}}[%
  meaning=Mellin-transform, OBSOLETE=1,
  args={f}{s},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{HilbertTrans}{\mathcal{H}}[%
  meaning=Hilbert-transform, OBSOLETE=1,
  args={f}{s},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{StieltjesTrans}{\mathcal{S}}[%
  meaning=Stieltjes-transform, OBSOLETE=1,
  args={f}{s},
  ]{2}[\mleft(#1;#2\mright)]
% These define the New higher order transforms. (note: lowercase "trans")
\defSpecFun{Fouriertrans}{\mathscr{F}}[%
  meaning=Fourier-transform, % om=?_dlmf,
  args={f},
  description={the Fourier transform of a function},% $\FourierTrans$},
  sortkey={F 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Fouriertransdist}{\mathscr{F}}[%
  meaning=distributional-Fourier-transform, % om=?_dlmf,
  args={f},
  description={the Fourier transform of a distribution},% $\FourierTrans$},
  sortkey={F 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Fouriercostrans}{\mathscr{F}_{\mkern-3mu\relax c}}[%
  meaning=Fourier-cosine-transform, % om=?_dlmf,
  description={the Fourier cosine transform of a function},% $\FourierCosTrans$},
  args={f},
  sortkey={F 1 1 c z},
  ]{1}[\mleft(#1\mright)][\mskip-1mu\relax#1\mskip3mu\relax]
\defSpecFun{Fouriersintrans}{\mathscr{F}_{\mkern-2mu\relax s}}[%
  meaning=Fourier-sine-transform, % om=?_dlmf,
  description={the Fourier sine transform of a function},% $\FourierSinTrans$},
  args={f},
  sortkey={F 1 1 s z},
  ]{1}[\mleft(#1\mright)][\mskip-1mu\relax#1\mskip3mu\relax]
\defSpecFun{Laplacetrans}{\mathscr{L}}[%
  meaning=Laplace-transform, % om=?_dlmf,
  description={the Laplace transform of a function},% $\LaplaceTrans$},
  args={f},
  sortkey={L 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Mellintrans}{\mathscr{M}}[%
  meaning=Mellin-transform, % om=?_dlmf,
  description={the Mellin transform of a function},% $\MellinTrans$},
  args={f},
  sortkey={M 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Hilberttrans}{\mathcal{H}}[%
  meaning=Hilbert-transform, % om=?_dlmf,
  args={f},
  description={the Hilbert transform of a function},% $\HilbertTrans$},
  sortkey={H 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Stieltjestrans}{\mathcal{S}}[%
  meaning=Stieltjes-transform, % om=?_dlmf,
  description={the Stieltjes transform of a function},% $\StieltjesTrans$},
  args={f},
  sortkey={S 1 0 z},
  ]{1}[\mleft(#1\mright)][\mskip-3mu\relax#1\mskip3mu\relax]
\defSpecFun{Fouriertrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Fouriercostrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Fouriersintrans.applied}{}[
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Laplacetrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Mellintrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Hilberttrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{Stieltjestrans.applied}{}[%
  args={s},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{deltaDistribution}[1][]{\delta_{#1}}[
  OBSOLETE=1,
  meaning=delta-distribution, % om=?_dlmf,
  params={x},
  description={the Dirac delta distribution at a point $x$},% $\deltaDistribution[x]$},
  sortkey={delta 0 1 z},
  ]{0}
% NOTE: Never actually defined (w/ or w/o optional arg!)
\defSpecFun{deltaDistribution[]}{\delta}[
  OBSOLETE=1,
  meaning=delta-distribution, % om=?_dlmf,
  description={the delta distribution},% $\deltaDistribution$},
  sortkey={delta 0 1 z},
  ]{0}
% NOTE: This description really isn't correct (or at least not complete)
\defSpecFun{intinnerprod}[2]{\mleft\langle #1,#2\mright\rangle}[
  meaning=distribution, % om=?_dlmf,
  params={\Lambda}{\phi},
  description={the inner-product (by integration)},% $\intinnerprod{\Lambda}{\phi}$},
  sortkey={*r< 2 0 z z},
  ]{0}
\defSpecFun{Schwarzian}[2]{\mleft\{ #1,#2\mright\}}[
  meaning=Schwarzian, % om=?_dlmf,
  params={z}{\zeta},
  description={the Schwarzian},% $\Schwarzian{z}{\zeta}$},
  sortkey={*q\{ 2 0 z z},
  ]{0}
\defSpecFun{HeavisideH}{H}[%
  meaning=Heaviside-H, % om=?_dlmf,
  args={x}, description={the Heaviside function},% $\HeavisideH$},
  sortkey={H 1 0 z},
   ]{1}
\defSpecFun{Diracdelta}{\delta}[%
  meaning=Dirac-delta, % om=?_dlmf,
  args={x},
  description={the Dirac delta functional (or distribution)},% $\Diracdelta$},
  sortkey={delta 1 1 z z},
  ]{1}
\defSpecFun{Diracdeltaseq}[1]{\delta_{#1}}[%
  meaning=Dirac-delta-sequence, % om=?_dlmf,
  params={n}, args={x},
  description={the Dirac delta sequence},% $\Diracdeltaseq[n]$},
  sortkey={delta 1 1 z z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from  %%% HSC: I don't know where to put these, so I 
                    %%%      putting them here. Please move at will.
\defSpecFun{equivmod}{\equiv}[%
  meaning=modular-equivalence, role=RELOP, om=equivalence:equivalence,
  args={x}, description={modular equivalence},% $\equiv$},
  sortkey={*b~ 0 0 equivmod},
  ]{0}
\defSpecFun{defeq}{\equiv}[%
  meaning=equal-by definition, role=RELOP, om=equals:definition,
  args={x}, description={equal by definition},% $=$},
  sortkey={*b~ 0 0 defeq},
  ]{0}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 2 Asymptotic Approximations
\defSpecFun{asympeq}{\sim}[%
  meaning=asymptotically-equals, role=RELOP, om=asymp1:asymptotic,
  args={x}, description={asymptotically equal},% $\asympeq$},
  sortkey={*b~ 0 0 eq},
  ]{0}
\defSpecFun{asympexp}{\sim}[%
  meaning=asymptotic-expansion, role=RELOP, om=asymp2_dlmf?:asymptotic_expansion,
  args={x}, description={asymptotic expansion (the right-hand side is the asymptotic expansion of the left-hand side)}, %, $\asympexp
  sortkey={*b~ 0 0 exp},
  ]{0}
\defSpecFun{bigO}{O}[%
  meaning=Big-O, om=asymp1:O,
  args={x}, description={the order not exceeding},% big $\bigO$},
  sortkey={O 1 0 z},
  ]{1}
\defSpecFun{littleo}{o}[%
  meaning=little-o, om=asymp1:o,
  args={x}, description={the order less than},% $\littleo$},
  sortkey={o 1 0 z},
  ]{1}
\defSpecFun{env}{\operatorname{env}}[%
  meaning=envelope,role=OPERATOR, % ??? om=asymp1_dlmf,
  args={f},
  description={the envelope of a function},% $\env$},
  sortkey={env 1 0 z},
  ]{1}[#1]
\defSpecFun{terminant}[1]{F_{#1}}[%
  meaning=terminant-function, om=expint3_dlmf:terminant,
  params={p},args={z},
  description={the terminant function},% $\terminant{p}$},
  sortkey={F 1 1 z z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 3 Numerical Methods
\defSpecFun{Pade}[3]{{[#1/#2]_{#3}}}[
  meaning=Pade-approximant, % om=?_dlmf,
  params={p}{q}{f}, args={z},
  description={the Pad\'e approximant},% $\Pade{p}{q}{f}$},
  sortkey={*n[ 3 1 z z z z}
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 4 Elementary Functions

% Logs & Exponentials
\defSpecFun{Ln}{\operatorname{Ln}}[%
  meaning=multivalued-natural-logarithm,role=OPFUNCTION, om=transc3:ln,
  args={z},
  description={the multivalued logarithm function},% $\Ln$},
  sortkey={Ln 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{ln}{\operatorname{ln}}[%
  base=1,meaning=natural-logarithm,role=OPFUNCTION, om=transc1:ln,
  args={z},
  description={the principal branch of logarithm function},% $\ln$},
  sortkey={ln 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{genlog}[1]{\operatorname{log}_{#1}}[%
  base=1,meaning=logarithm,role=OPFUNCTION, om=transc1:log,
  params={a}, args={z},
  description={the logarithm to general base $a$},% $\genlog{a}$},
  sortkey={log 1 1 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{log}{\operatorname{log}}[%
  base=1,meaning=logarithm,role=OPFUNCTION, % om=?_dlmf,% log base 10?
  args={z},
  description={the logarithm to base 10},% $\log$},
  sortkey={log 1 0 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{exp}{\operatorname{exp}}[%
  base=1,meaning=exponential,role=OPFUNCTION, om=transc1:exp,
  args={z},
  description={the exponential function},% $\exp$},
  sortkey={exp 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{LambertW}{W}[%
  meaning=Lambert-W, om=lambert1_dlmf:W,
  args={x},
  description={the Lambert $\LambertW$-function},
  sortkey={W 1 0 z},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{LambertWp}{\mathrm{Wp}}[%
  meaning=Lambert-Wp, om=lambert1_dlmf:Wp,
  args={x},
  description={the principal branch of the Lambert $\LambertW$-function},% $\LambertWp$},
  sortkey={Wp 1 0 z},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{LambertWm}{\mathrm{Wm}}[%
  meaning=Lambert-Wm, om=lambert1_dlmf:Wm,
  args={x},
  description={the non-principal branch of the Lambert $\LambertW$-function},% $\LambertWm$},
  sortkey={Wm 1 0 z},
  ]{1}[\mleft(#1\mright)]
% Trig
\defSpecFun{sin}{\operatorname{sin}}[%
  base=1,meaning=sine,role=TRIGFUNCTION, om=transc1:sin,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the sine function},% $\sin$},
  sortkey={sin 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{cos}{\operatorname{cos}}[%
  base=1,meaning=cosine,role=TRIGFUNCTION, om=transc1:cos,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the cosine function},% $\cos$},
  sortkey={cos 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{tan}{\operatorname{tan}}[%
  base=1,meaning=tangent,role=TRIGFUNCTION, om=transc1:tan,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the tangent function},% $\tan$},
  sortkey={tan 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{csc}{\operatorname{csc}}[%
  base=1,meaning=cosecant,role=TRIGFUNCTION, om=transc1:csc,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the cosecant function},% $\csc$},
  sortkey={csc 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{sec}{\operatorname{sec}}[%
  base=1,meaning=secant,role=TRIGFUNCTION, om=transc1:sec,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the secant function},%$\sec$},
  sortkey={sec 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{cot}{\operatorname{cot}}[%
  base=1,meaning=cotangent,role=TRIGFUNCTION, om=transc1:cot,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the cotangent function},% $\cot$},
  sortkey={cot 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
% Arc trig
\defSpecFun{Asin}{\operatorname{Arcsin}}[%
  meaning=multivalued-inverse-sine,role=OPFUNCTION, om=transc3:arcsin,
  args={z},
  description={the multivalued inverse of the sine function},% $\Asin$},
  sortkey={Arcsin 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acos}{\operatorname{Arccos}}[%
  meaning=multivalued-inverse-cosine,role=OPFUNCTION, om=transc3:arccos,
  args={z},
  description={the multivalued inverse of the cosine function},% $\Acos$},
  sortkey={Arccos 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Atan}{\operatorname{Arctan}}[%
  meaning=multivalued-inverse-tangent,role=OPFUNCTION, om=transc3:arctan,
  args={z},
  description={the multivalued inverse of the tangent function},% $\Atan$},
  sortkey={Arctan 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acsc}{\operatorname{Arccsc}}[%
  meaning=multivalued-inverse-cosecant,role=OPFUNCTION, om=transc3:arccsc,
  args={z},
  description={the multivalued inverse of the cosecant function},% $\Acsc$},
  sortkey={Arccsc 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Asec}{\operatorname{Arcsec}}[%
  meaning=multivalued-inverse-secant,role=OPFUNCTION, om=transc3:arccsc,
  args={z},
  description={the multivalued inverse of the secant function},% $\Asec$},
  sortkey={Arcsec 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acot}{\operatorname{Arccot}}[%
  meaning=multivalued-inverse-cotangent,role=OPFUNCTION, om=transc3:arccot,
  args={z},
  description={the multivalued inverse of the cotangent function},% $\Acot$},
  sortkey={Arccot 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{asin}{\operatorname{arcsin}}[%
  meaning=inverse-sine,role=OPFUNCTION, om=transc1:arcsin,
  args={z},
  description={the inverse of the sine function},% $\asin$},
  sortkey={arcsin 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acos}{\operatorname{arccos}}[%
  meaning=inverse-cosine,role=OPFUNCTION, om=transc1:arccos,
  args={z},
  description={the inverse of the cosine function},% $\acos$},
  sortkey={arccos 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{atan}{\operatorname{arctan}}[%
  meaning=inverse-tangent,role=OPFUNCTION, om=transc1:arctan,
  args={z},
  description={the inverse of the tangent function},% $\atan$},
  sortkey={arctan 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acsc}{\operatorname{arccsc}}[%
  meaning=inverse-cosecant,role=OPFUNCTION, om=transc1:arccsc,
  args={z},
  description={the inverse of the cosecant function},% $\acsc$},
  sortkey={arccsc 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{asec}{\operatorname{arcsec}}[%
  meaning=inverse-secant,role=OPFUNCTION, om=transc1:arcsec,
  args={z},
  description={the inverse of the secant function},% $\asec$},
  sortkey={arcsec 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acot}{\operatorname{arccot}}[%
  meaning=inverse-cotangent,role=OPFUNCTION, om=transc1:arccot,
  args={z},
  description={the inverse of the cotangent function},% $\acot$},
  sortkey={arccot 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
% Gudermannian
\defSpecFun{Gudermannian}{\operatorname{gd}}[%
  meaning=Gudermannian, om=transc4_dlmf:Gudermannian,
  args={z},
  description={the Gudermannian function},% $\Gudermannian$},
  sortkey={gd 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{aGudermannian}{{\operatorname{gd}^{-1}}}[%
  meaning=inverse-Gudermannian,role=OPFUNCTION, om=transc4_dlmf:arc-Gudermannian,
  args={z},
  description={the inverse of the Gudermannian function},% $\aGudermannian$},
  sortkey={gd 1 2 -1 z},
  ]{1}[\mleft(#1\mright)][#1]
% Hyperbolic trig
\defSpecFun{sinh}{\operatorname{sinh}}[%
  base=1,meaning=hyperbolic-sine,role=TRIGFUNCTION, om=transc1:sinh,
  args={z},
  description={the hyperbolic sine function},% $\sinh$},
  sortkey={sinh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{cosh}{\operatorname{cosh}}[%
  base=1,meaning=hyperbolic-cosine,role=TRIGFUNCTION, om=transc1:cosh,
  args={z},
  description={the hyperbolic cosine function},% $\cosh$},
  sortkey={cosh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{tanh}{\operatorname{tanh}}[%
  base=1,meaning=hyperbolic-tangent,role=TRIGFUNCTION, om=transc1:tanh,
  args={z},
  description={the hyperbolic tangent function},% $\tanh$},
  sortkey={tanh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{csch}{\operatorname{csch}}[%
  meaning=hyperbolic-cosecant,role=TRIGFUNCTION, om=transc1:csch,
  args={z},
  description={the hyperbolic cosecant function},% $\csch$},
  sortkey={csch 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{sech}{\operatorname{sech}}[%
  meaning=hyperbolic-secant,role=TRIGFUNCTION, om=transc1:sech,
  args={z},
  description={the hyperbolic secant function},% $\sech$},
  sortkey={sech 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{coth}{\operatorname{coth}}[%
  base=1,meaning=hyperbolic-cotangent,role=TRIGFUNCTION, om=transc1:coth,
  args={z},
  description={the hyperbolic cotangent function},% $\coth$},
  sortkey={coth 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
% Arc Hyperbolic trig
\defSpecFun{Asinh}{\operatorname{Arcsinh}}[%
  meaning=multivalued-hyperbolic-inverse-sine,role=OPFUNCTION, om=transc3:arcsinh,
  args={z},
  description={the multivalued inverse of the hyperbolic sine function},% $\Asinh$},
  sortkey={Arcsinh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acosh}{\operatorname{Arccosh}}[%
  meaning=multivalued-hyperbolic-inverse-cosine,role=OPFUNCTION, om=transc3:arccosh,
  args={z},
  description={the multivalued inverse of the hyperbolic cosine function},% $\Acosh$},
  sortkey={Arccosh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Atanh}{\operatorname{Arctanh}}[%
  meaning=multivalued-hyperbolic-inverse-tangent,role=OPFUNCTION, om=transc3:arctanh,
  args={z},
  description={the multivalued inverse of the hyperbolic tangent function},% $\Atanh$},
  sortkey={Arctanh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acsch}{\operatorname{Arccsch}}[%
  meaning=multivalued-hyperbolic-inverse-cosecant,role=OPFUNCTION, om=transc3:arccsch,
  args={z},
  description={the multivalued inverse of the hyperbolic cosecant function},% $\Acsch$},
  sortkey={Arccsch 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Asech}{\operatorname{Arcsech}}[%
  meaning=multivalued-hyperbolic-inverse-secant,role=OPFUNCTION, om=transc3:arcsech,
  args={z},
  description={the multivalued inverse of the hyperbolic secant function},% $\Asech$},
  sortkey={Arcsech 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Acoth}{\operatorname{Arccoth}}[%
  meaning=multivalued-hyperbolic-inverse-cotangent,role=OPFUNCTION, om=transc3:arccoth,
  args={z},
  description={the multivalued inverse of the hyperbolic cotangent function},% $\Acoth$},
  sortkey={Arccoth 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{asinh}{\operatorname{arcsinh}}[%
  meaning=hyperbolic-inverse-sine,role=OPFUNCTION, om=transc1:arcsinh,
  args={z},
  description={the inverse of the hyperbolic sine function},% $\asinh$},
  sortkey={arcsinh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acosh}{\operatorname{arccosh}}[%
  meaning=hyperbolic-inverse-cosine,role=OPFUNCTION, om=transc1:arccosh,
  args={z},
  description={the inverse of the hyperbolic cosine function},% $\acosh$},
  sortkey={arccosh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{atanh}{\operatorname{arctanh}}[%
  meaning=hyperbolic-inverse-tangent,role=OPFUNCTION, om=transc1:arctanh,
  args={z},
  description={the inverse of the hyperbolic tangent function},% $\atanh$},
  sortkey={arctanh 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acsch}{\operatorname{arccsch}}[%
  meaning=hyperbolic-inverse-cosecant,role=OPFUNCTION, om=transc1:arcsch,
  args={z},
  description={the inverse of the hyperbolic cosecant function},% $\acsch$},
  sortkey={arccsch 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{asech}{\operatorname{arcsech}}[%
  meaning=hyperbolic-inverse-secant,role=OPFUNCTION, om=transc1:arcsech,
  args={z},
  description={the inverse of the hyperbolic secant function},% $\asech$},
  sortkey={arcsech 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{acoth}{\operatorname{arccoth}}[%
  meaning=hyperbolic-inverse-cotangent,role=OPFUNCTION, om=transc1:arccoth,
  args={z},
  description={the inverse of the hyperbolic cotangent function},% $\acoth$},
  sortkey={arccoth 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 5 Gamma Function
\defSpecFun{EulerGamma}{\Gamma}[%
  meaning=Euler-Gamma, om=hypergeo0:gamma, % ?
  args={z},
  description={the Euler gamma function},% $\EulerGamma$},
  sortkey={Gamma 1 0 z},
  ]{1}
\defSpecFun{digamma}{\psi}[%
  meaning=digamma, om=gamma1_dlmf:digamma,
  args={z},
  description={the digamma (or psi) function},% $\digamma$},
  sortkey={psi 1 0 z},
  ]{1}
\defSpecFun{EulerBeta}{\mathrm{B}}[%
  meaning=Euler-Beta, om=hypergeo0:beta, % ?
  args={a}{b},
  description={the Euler beta function},% $\EulerBeta$},
  sortkey={B 2 0 z z},
  ]{2}
\defSpecFun{polygamma}[1]{\psi^{(#1)}}[%
  meaning=polygamma, om=gamma1_dlmf:polygamma,
  params={n}, args={z},
  description={the polygamma function},% $\polygamma{n}$},
  sortkey={psi 1 2 z z},
  ]{1}
\defSpecFun{BarnesG}{G}[%
  meaning=Barnes-Gamma, om=gamma1_dlmf:Barnes,
  args={z},
  description={the Barne's $\BarnesG$-function (or double gamma) function},
  sortkey={G 1 0 z},
  ]{1}
\defSpecFun{qGamma}[1]{\Gamma_{#1}}[%
  meaning=q-Gamma, om=gamma2_dlmf:qgamma,
  params={q}, args={z},
  description={the $q$-gamma function},% $\qGamma{q}$},
  sortkey={Gamma 1 1 z z},
  ]{1}
\defSpecFun{qBeta}[1]{\mathrm{B}_{#1}}[%
  meaning=q-Beta, om=gamma2_dlmf:qBeta,
  params={q}, args={a}{b},
  description={the $q$-Beta function},% $\qBeta{q}$},
  sortkey={B 2 1 z z z},
  ]{2}
\defSpecFun{qDigamma}[1]{\psi_{#1}}[%
  meaning=q-digamma, om=gamma2_dlmf:qdigamma,
  params={q}, args={z},
  description={the $q$-digamma function},% $\qDigamma{q}$},
  sortkey={psi 1 1 z z},
  ]{1}
\defSpecFun{qpolygamma}[2]{\psi^{(#1)}_{#2}}[%
  meaning=q-polygamma, om=gamma2_dlmf:qpolygamma,
  params={n}{q}, args={z},
  description={the $q$-polygamma function},% $\qpolygamma{n}{q}$},
  sortkey={psi 1 3 z z z},
  ]{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 6 Exponential, Logarithmic, Sine, and Cosine Integrals
\defSpecFun{expintE}{E_1}[%
  meaning=exponential-integral, om=expint2_dlmf:E1,
  args={z},
  description={the exponential integral $\expintE$},
  sortkey={E 1 1 z z},
  ]{1}
\defSpecFun{expintEin}{\mathrm{Ein}}[%
  meaning=complementary-exponential-integral, om=expint2_dlmf:Ein,
  args={z},
  description={the complementary exponential integral},% $\expintEin$},
  sortkey={Ein 1 0 z},
  ]{1}
\defSpecFun{expintEi}{\mathrm{Ei}}[%
  meaning=exponential-integral-Ei, om=expint:Ei,
  args={z},
  description={the exponential integral $\expintEi$},
  sortkey={Ei 1 0 z},
  ]{1}
\defSpecFun{logint}{\mathrm{li}}[%
  meaning=logarithmic-integral, om=expint:li,
  args={z},
  description={the logarithmic integral},% $\logint$},
  sortkey={li 1 0 z},
  ]{1}
\defSpecFun{sinint}{\mathrm{Si}}[%
  meaning=sine-integral, om=expint2_dlmf:Si,
  args={z},
  description={the sine integral $\sinint$},
  sortkey={Si 1 0 z},
  ]{1}
\defSpecFun{shiftsinint}{\mathrm{si}}[%
  meaning=shifted-sine-integral, om=expint2_dlmf:si,
  args={z},
  description={the shifted sine integral},% $\shiftsinint$},
  sortkey={si 1 0 z},
  ]{1}
\defSpecFun{cosint}{\mathrm{Ci}}[%
  meaning=cosine-integral, om=expint2_dlmf:Ci,
  args={z},
  description={the cosine integral $\cosint$},
  sortkey={Ci 1 0 z},
  ]{1}
\defSpecFun{cosintCin}{\mathrm{Cin}}[%
  meaning=cosine-integral-Cin, om=expint2_dlmf:Cin,
  args={z},
  description={the cosine integral $\cosintCin$},
  sortkey={Cin 1 0 z},
  ]{1}
\defSpecFun{sinhint}{\mathrm{Shi}}[%
  meaning=hyperbolic-sine-integral, om=expint2_dlmf:Shi,
  args={z},
  description={the hyperbolic sine integral},% $\sinhint$},
  sortkey={Shi 1 0 z},
  ]{1}
\defSpecFun{coshint}{\mathrm{Chi}}[%
  meaning=hyperbolic-cosine-integral, om=expint2_dlmf:Chi,
  args={z},
  description={the hyperbolic cosine integral},% $\coshint$},
  sortkey={Chi 1 0 z},
  ]{1}
\defSpecFun{auxsincosintf}{\mathrm{f}}[%
  meaning=sine-cosine-integral-f, om=expint2_dlmf:f,
  args={z},
  description={the auxiliary function for sine and cosine integrals $\auxsincosintf$},
  sortkey={f 1 0 z},
  ]{1}
\defSpecFun{auxsincosintg}{\mathrm{g}}[%
  meaning=sine-cosine-integral-g, om=expint2_dlmf:g,
  args={z},
  description={the auxiliary function for sine and cosine integrals $\auxsincosintg$},
  sortkey={g 1 0 z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 7 Error Functions, Dawson’s and Fresnel Integrals
\defSpecFun{erf}{\operatorname{erf}}[%
  meaning=error-function,role=OPFUNCTION, om=errfun1_dlmf:erf,
  args={z},
  description={the error function},% $\erf$},
  sortkey={erf 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{erfc}{\operatorname{erfc}}[%
  meaning=complementary-error-function,role=OPFUNCTION, om=errfun1_dlmf:erfc,
  args={z},
  description={the complementary error function $\erfc$},
  sortkey={erfc 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Faddeevaw}{w}[%
  meaning=error-function-w,role=OPFUNCTION, om=errfun1_dlmf:erfw,
  args={z},
  description={the complementary error function $\Faddeevaw$},
  sortkey={erfw 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{DawsonsintF}{F}[%
  meaning=Dawsons-integral, om=errfun2_dlmf:Dawson_F,
  args={z},
  description={Dawson's integral},% $F$},
  sortkey={F 1 0 z},
  ]{1}
\defSpecFun{FresnelintF}{\mathcal{F}}[%
  meaning=Fresnel-integral, om=errfun2_dlmf:Fresnel_F,
  args={z},
  description={the Fresnel integral},% $\FresnelintF$},
  sortkey={F 1 0 z},
  ]{1}
\defSpecFun{Fresnelcosint}{C}[%
  meaning=Fresnel-cosine-integral, om=errfun2_dlmf:Fresnel_cos,
  args={z},
  description={the Fresnel cosine integral},% $\Fresnelcosint$},
  sortkey={C 1 0 z},
  ]{1}
\defSpecFun{Fresnelsinint}{S}[%
  meaning=Fresnel-sine-integral, om=errfun2_dlmf:Fresnel_sin,
  args={z},
  description={the Fresnel sine integral},% $\Fresnelsinint$},
  sortkey={S 1 0 z},
  ]{1}
\defSpecFun{auxFresnelf}{\mathrm{f}}[%
  meaning=Fresnel-auxilliary-function-f, om=errfun2_dlmf:Fresnel_aux_f,
  args={z},
  description={the auxiliary function for Fresnel integrals $\auxFresnelf$},
  sortkey={f 1 0 z},
  ]{1}
\defSpecFun{auxFresnelg}{\mathrm{g}}[%
  meaning=Fresnel-auxilliary-function-g, om=errfun2_dlmf:Fresnel_aux_g,
  args={z},
  description={the auxiliary function for Fresnel integrals $\auxFresnelg$},
  sortkey={g 1 0 z},
  ]{1}
\defSpecFun{GoodwinStatonint}{G}[%
  meaning=Goodwin-Staton-integral, om=errfun2_dlmf:Goodwin-Staton,
  args={z},
  description={the Goodwin--Staton integral},% $\GoodwinStatonint$},
  sortkey={G 1 0 z},
  ]{1}
\defSpecFun{MillsM}{\mathsf{M}}[%
  meaning=Mills-ratio, om=errfun3_dlmf:Mills_ratio,
  args={x},
  description={Mill's ratio},% $\MillsM$},
  sortkey={M 1 0 z},
  ]{1}
\defSpecFun{inverf}{\operatorname{inverf}}[%
  meaning=inverse-error-function,role=OPFUNCTION, om=errfun1_dlmf:inverf,
  args={x},
  description={the inverse error function},% $\inverf$},
  sortkey={inverf 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{inverfc}{\operatorname{inverfc}}[%
  meaning=inverse-complementary-error-function,role=OPFUNCTION, om=errfun1_dlmf:inverfc,
  args={x},
  description={the inverse complementary error function},% $\inverfc$},
  sortkey={inverfc 1 0 z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{repinterfc}[1]{\mathop{\mathrm{i}^{#1}\mathrm{erfc}}}[%
  meaning=repeated-integral-complementary-error-function, role=OPFUNCTION, om=errfun1_dlmf:repinterfc,
  params={n}, args={z},
  description={the repeated integrals of complementary error function},% $\repinterfc{n}$},
  sortkey={ierfc 1 2 z z},
  ]{1}
\defSpecFun{VoigtU}{\mathsf{U}}[%
  meaning=Voigt-U, om=errfun3_dlmf:Voigt_U,
  args={x}{t},
  description={the Voigt function $\VoigtU$},
  sortkey={U 2 0 z z},
  ]{2}
\defSpecFun{VoigtV}{\mathsf{V}}[%
  meaning=Voigt-V, om=errfun3_dlmf:Voigt_V,
  args={x}{t},
  description={the Voigt function $\VoigtV$},
  sortkey={V 2 0 z z},
  ]{2}
\defSpecFun{VoigtH}{H}[%
  meaning=line-broadening-function, om=errfun3_dlmf:line-broadening,
  args={a}{u},
  description={the line broadening function},% $\VoigtH$},
  sortkey={H 2 0 z z}
  ]{2}
\defSpecFun{FishersHh}[1]{\mathit{Hh}_{#1}}[%
  meaning=Fishers-Hh, om=errfun3_dlmf:Fischer_Hh,
  params={n}, args={z},
  description={Fischer's probability function},% $\FishersHh{n}$},
  sortkey={Hh 1 1 z z},
  ]{1}[\mleft(#1\mright)]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 8 Incomplete Gamma and Related Functions
\defSpecFun{incgamma}{\gamma}[%
  meaning=incomplete-gamma, om=expint3_dlmf:gamma,
  args={a}{z},
  description={the lower incomplete gamma function},% $\incgamma$},
  sortkey={gamma 2 0 z z},
  ]{2}
\defSpecFun{incGamma}{\Gamma}[%
  meaning=incomplete-Gamma, om=expint3_dlmf:Gamma,
  args={a}{z},
  description={the upper incomplete gamma function},% $\incGamma$},
  sortkey={Gamma 2 0 z z},
  ]{2}
\defSpecFun{normincGammaP}{P}[%
  meaning=incomplete-gamma-P, om=expint3_dlmf:GammaP,
  args={a}{z},
  description={the normalized incomplete gamma function $\normincGammaP$},
  sortkey={P 2 0 z z},
  ]{2}
\defSpecFun{normincGammaQ}{Q}[%
  meaning=incomplete-gamma-Q, om=expint3_dlmf:GammaQ,
  args={a}{z},
  description={the normalized incomplete gamma function $\normincGammaQ$},
  sortkey={Q 2 0 z z},
  ]{2}
\defSpecFun{scincgamma}{\gamma^{*}}[%
  meaning=incomplete-gamma-star, om=expint3_dlmf:scaled_gamma,
  args={a}{z},
  description={the scaled incomplete gamma function},% $\scincgamma$},
  sortkey={gamma 2 2 * z z},
  ]{2}
\defSpecFun{incBeta}[1]{\mathrm{B}_{#1}}[%
  meaning=incomplete-Beta, om=expint3_dlmf:Beta,
  params={x}, args={a}{b},
  description={the incomplete beta function},% $\incBeta{x}$},
  sortkey={B 2 1 z z z},
  ]{2}
\defSpecFun{normincBetaI}[1]{I_{#1}}[%
  meaning=IncI, om=expint3_dlmf:I,
  params={x}, args={a}{b},
  description={the normalized incomplete beta function},% $IncI{x}$},
  sortkey={I 2 1 z z z},
  ]{2}
\defSpecFun{genexpintE}[1]{E_{#1}}[%
  meaning=exponential-integral-En, om=expint:E,
  params={p}, args={z},
  description={the generalized exponential integral},% $\genexpintE{p}$},
  sortkey={E 1 1 z z},
  ]{1}
\defSpecFun{genshiftsinint}{\mathrm{si}}[%
  meaning=generalized-sine-integral-si, om=expint3_dlmf:si,
  args={a}{z},
  description={the generalized shifted sine integral},% $\genshiftsinint$},
  sortkey={si 2 0 z z},
  ]{2}
\defSpecFun{genshiftcosint}{\mathrm{ci}}[%
  meaning=generalized-cosine-integral-ci, om=expint3_dlmf:ci,
  args={a}{z},
  description={the generalized shifted cosine integral},% $\genshiftcosint$},
  sortkey={ci 2 0 z z},
  ]{2}
\defSpecFun{gensinint}{\mathrm{Si}}[%
  meaning=generalized-sine-integral-Si, om=expint3_dlmf:Si,
  args={a}{z},
  description={the generalized sine integral},% $\gensinint$},
  sortkey={Si 2 0 z z},
  ]{2}
\defSpecFun{gencosint}{\mathrm{Ci}}[%
  meaning=generalized-cosine-integral-Ci, om=expint3_dlmf:Ci,
  args={a}{z},
  description={the generalized cosine integral},% $\gencosint$},
  sortkey={Ci 2 0 z z},
  ]{2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 9 Airy and Related Functions
\defSpecFun{AiryAi}{\mathrm{Ai}}[%
   meaning=Airy-Ai, om=DLMF_AI:AiryAi, omequiv=airy:Ai,
   args={z},
   signature={\Complexes\mapsto\Complexes},
   description={the Airy function $\AiryAi$},
   sortkey={Ai 1 0 z},
   ]{1}
\defSpecFun{AiryBi}{\mathrm{Bi}}[%
   meaning=Airy-Bi, om=DLMF_AI:AiryBi, omequiv=airy:Bi,
   args={z},
   signature={\Complexes\mapsto\Complexes},
   description={the Airy function $\AiryBi$},
   sortkey={Bi 1 0 z},
   ]{1}
\defSpecFun{AirymodM}{M}[%
   meaning=modulus-Airy-M, om=DLMF_AI_mag:AirymodM,
   args={x},
   signature={\Reals\mapsto\Reals},
   description={the modulus of Airy functions},% $\AirymodM$},
   sortkey={M 1 0 z},
   ]{1}
\defSpecFun{Airyphasetheta}{\theta}[%
   meaning=phase-Airy-Theta, om=DLMF_AI_mag:Airyphasetheta,
   args={x},
   signature={\Reals\mapsto\Reals},
   description={the phase of Airy functions},% $\Airyphasetheta$},
   sortkey={theta 1 0 z},
   ]{1}
\defSpecFun{AirymodderivN}{N}[%
   meaning=modulus-Airy-N, om=DLMF_AI_mag:AirymodderivN,
   args={x},
   signature={\Reals\mapsto\Reals},
   description={the modulus of derivatives of Airy functions},% $\AirymodderivN$},
   sortkey={N 1 0 z},
   ]{1}
\defSpecFun{Airyphasederivphi}{\phi}[%
   meaning=phase-Airy-Phi, om=DLMF_AI_mag:Airyphasederivphi,
   args={x},
   signature={\Reals\mapsto\Reals},
   description={the phase of derivatives of Airy functions},% $\Airyphasederivphi$},
   sortkey={phi 1 0 z},
   ]{1}
% Wasn't defined in AI, but should have been.
\defSpecFun{envAiryAi}{\mathrm{envAi}}[
  meaning=envelope-Airy-Ai, om=DLMF_AI_mag:envAiryAi,
  args={x},
  signature={\Reals\mapsto\Reals},
  description={the envelope of the Airy function $\AiryAi$},% $\envAiryAi$},
  sortkey={envAi 1 0 z},
  ]{1}
\defSpecFun{envAiryBi}{\mathrm{envBi}}[
  meaning=envelope-Airy-Bi, om=DLMF_AI_mag:envAiryBi,
  args={x},
  signature={\Reals\mapsto\Reals},
  description={the envelope of the Airy function $\AiryBi$},% $\envAiryBi$},
  sortkey={envBi 1 0 z},
  ]{1}
\defSpecFun{zAirya}[1]{a_{#1}}[%
   meaning=zero-Airy-Ai, om=DLMF_AI_z:zAirya,
   params={k},
   signature={\posIntegers\mapsto\Reals},
   description={the $k$\textsuperscript{th} zero of Airy $\AiryAi$},% $\zAirya{k}$},
   sortkey={a 0 1 z},
   ]{0}
\defSpecFun{zAiryb}[1]{b_{#1}}[%
  meaning=zero-Airy-Bi, om=DLMF_AI_z:zAiryb,
   params={k},
   signature={\posIntegers\mapsto\Reals},
   description={the $k$\textsuperscript{th} zero of Airy $\AiryBi$},% $\zAiryb{k}$},
   sortkey={b 0 1 z},
   ]{0}
\defSpecFun{zderivAirya}[1]{a'_{#1}}[%
   meaning=zero-derivative-Airy-Ai, om=DLMF_AI_z:zderivAirya,
   params={k},
   signature={\posIntegers\mapsto\Reals},
   description={the $k$\textsuperscript{th} zero of Airy $\AiryAi'$},% $\zderivAirya{k}$},
   sortkey={a 0 3 z z},
   ]{0}
\defSpecFun{zderivAiryb}[1]{b'_{#1}}[%
   meaning=zero-derivative-Airy-Bi, om=DLMF_AI_z:zderivAiryb,
   params={k},
   signature={\posIntegers\mapsto\Reals},
   description={the $k$\textsuperscript{th} zero of Airy $\AiryBi'$},% $\zderivAiryb{k}$},
   sortkey={b 0 3 z z},
   ]{0}
\defSpecFun{zAirybeta}[1]{\beta_{#1}}[
   meaning=complex-zero-Airy-Bi, om=DLMF_AI_z:zAirybeta,
   params={k},
   signature={\posIntegers\mapsto\Complexes},
   description={the $k$\textsuperscript{th} complex zero of Airy $\AiryBi$},% $\zAirybeta{k}$},
   sortkey={beta 0 1 z},
   ]{0}
\defSpecFun{zderivAirybeta}[1]{\beta'_{#1}}[%
   meaning=complex-zero-derivative-Airy-Bi, om=DLMF_AI_z:zderivAirybeta,
   params={k},
   signature={\posIntegers\mapsto\Complexes},
   description={the $k$\textsuperscript{th} complex zero of Airy $\AiryBi'$},% $\zderivAirybeta{k}$},
   sortkey={beta 0 3 z z},
   ]{0}

% Scorer functions
\defSpecFun{ScorerGi}{\mathrm{Gi}}[%
  meaning=Scorer-Gi, om=DLMF_AI:ScorerGi,
  args={z},
  signature={\Complexes\mapsto\Complexes},
  description={the Scorer (or inhomogeneous Airy) function $\ScorerGi$},
  sortkey={Gi 1 0 z},
  ]{1}
\defSpecFun{ScorerHi}{\mathrm{Hi}}[%
  meaning=Scorer-Hi, om=DLMF_AI:ScorerHi,
  args={z},
   signature={\Complexes\mapsto\Complexes},
  description={the Scorer (or inhomogeneous Airy) function $\ScorerHi$},
  sortkey={Hi 1 0 z},
  ]{1}

% Generalizations
\defSpecFun{genAiryODEA}[1]{A_{#1}}[%
  meaning=ODE-generalized-Airy-A, om=DLMF_AI_gen:genAiryODEA,
  params={n}, args={z},
  signature={\posIntegers\times\Complexes\mapsto\Complexes},
  description={the generalized Airy function (ODE) $\genAiryODEA{n}$},
  sortkey={A 1 1 z z},
  ]{1}
\defSpecFun{genAiryODEB}[1]{B_{#1}}[
  meaning=ODE-generalized-Airy-B, om=DLMF_AI_gen:genAiryODEB,
  params={n}, args={z},
  signature={\posIntegers\times\Complexes\mapsto\Complexes},
  description={the generalized Airy function (ODE) $\genAiryODEB{n}$},
  sortkey={B 1 1 z z},
  ]{1}
\defSpecFun{genAiryintA}[1]{A_{#1}}[%
  meaning=Integral-generalized-Airy-A, om=DLMF_AI_gen:genAiryintA,
  params={k}, args={z}{p},
  signature={\posIntegers\times\Complexes\times\Complexes\mapsto\Complexes},
  description={the generalized Airy function (integral) $\genAiryintA{k}$},
  sortkey={A 2 1 z z z},
  ]{2}
\defSpecFun{genAiryintB}[1]{B_{#1}}[
  meaning=Integral-generalized-Airy-B, om=DLMF_AI_gen:genAiryintB,
  params={k}, args={z}{p},
  signature={\posIntegers\times\Complexes\times\Complexes\mapsto\Complexes},
  description={the generalized Airy function (integral) $\genAiryintB{k}$},
  sortkey={B 2 1 z z z},
  ]{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 10 Bessel Functions

% Bessel Functions
\defSpecFun{BesselJ}[1]{J_{#1}}[%
  meaning=Bessel-J, om=DLMF_BS:BesselJ,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the Bessel function of the first kind},% $\BesselJ{\nu}$},
  sortkey={J 1 1 z z},
  ]{1}
\defSpecFun{BesselY}[1]{Y_{#1}}[%
  meaning=Bessel-Y-Weber, om=DLMF_BS:BesselY,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the Bessel function of the second kind},% $\BesselY{\nu}$},
  sortkey={Y 1 1 z z},
  ]{1}
\defSpecFun{HankelH}[2]{{H^{(#1)}_{#2}}}[% Stub for indexed defns
  params={i}{\nu},
  signature={\{1,2\}\times\Complexes\mapsto\Complexes},
  description={placekeeper for indexed Hankel functions},
  ]{0}%
\defSpecFun{HankelH{1}}[1]{{H^{(1)}_{#1}}}[%
  meaning=Hankel-H-1-Bessel-third-kind, om=DLMF_BS:HankelH1,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the Hankel function of the first kind% $\HankelH{1}{\nu}$
    (or Bessel function of the third kind)},
  sortkey={H 1 3 1 z z},
  ]{1}
\defSpecFun{HankelH{2}}[1]{{H^{(2)}_{#1}}}[%
  meaning=Hankel-H-2-Bessel-third-kind, om=DLMF_BS:HankelH2,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the Hankel function of the second kind% $\HankelH{2}{\nu}$
    (or Bessel function of the third kind)},
  sortkey={H 1 3 2 z z},
  ]{1}
\defSpecFun{BesselC}[1]{\mathscr{C}_{#1}}[%
  meaning=cylinder-function, om=DLMF_BS_mag:BesselC,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the Bessel cylinder function},% $\BesselC{\nu}$},
  sortkey={C 1 1 z z},
  ]{1}
% Question: Why are these restricted to real x?
\defSpecFun{HankelmodM}[1]{M_{#1}}[%
  meaning=modulus-Bessel-M, om=DLMF_BS_mag:HankelmodM,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the modulus of the Hankel function of the first kind},% $\HankelmodM{\nu}$},
  sortkey={M 1 1 z z},
  ]{1}
\defSpecFun{HankelmodderivN}[1]{N_{#1}}[%
  meaning=modulus-Bessel-N, om=DLMF_BS_mag:HankelmodderivN,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the modulus of derivatives of the Hankel function of the first kind},% $\HankelmodderivN{\nu}$},
  sortkey={N 1 1 z z},
  ]{1}
\defSpecFun{Hankelphasetheta}[1]{\theta_{#1}}[%
  meaning=phase-Bessel-Theta, om=DLMF_BS_mag:Hankelphasetheta,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the phase of the Hankel function of the first kind},% $\Hankelphasetheta{\nu}$},
  sortkey={theta 1 1 z z},
  ]{1}
\defSpecFun{Hankelphasederivphi}[1]{\phi_{#1}}[%
  meaning=phase-Bessel-Phi, om=DLMF_BS_mag:Hankelphasederivphi,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the phase of derivatives of the Hankel function of the first kind},% $\Hankelphasederivphi{\nu}$},
  sortkey={phi 1 1 z z},
  ]{1}
% Wasn't defined in BS, but should have been.
\defSpecFun{envBesselJ}[1]{\mathrm{env}\mskip-2mu\relax J_{#1}}[%
  meaning=envelope-Bessel-J, om=DLMF_BS_mag:envBesselJ,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the envelope of the Bessel function $\BesselJ{\nu}$},% $\envBesselJ{\nu}$},
  sortkey={envJ 1 1 z z},
  ]{1}
\defSpecFun{envBesselY}[1]{\mathrm{env}\mskip-2mu\relax Y_{#1}}[%
  meaning=envelope-Bessel-Y, om=DLMF_BS_mag:envBesselY,
  params={\nu}, args={x},
  signature={\Complexes\times\Reals\mapsto\Reals},
  description={the envelope of the Bessel function $\BesselY{\nu}$},% $\envBesselY{\nu}$},
  sortkey={envY 1 1 z z},
  ]{1}
\defSpecFun{zBesselj}[2]{j_{#1,#2}}[%
  meaning=zero-Bessel-J, om=DLMF_BS_z:zBesselj,
  params={\nu}{m},
  signature={\Reals\times\posIntegers\mapsto\Reals},
  description={the $m$\textsuperscript{th} zero of the Bessel function
     of the first kind $\BesselJ{\nu}$},
%     $\zBesselj{\nu}{m}$},  
  sortkey={j 0 1 zz},
  ]{0}
\defSpecFun{zBessely}[2]{y_{#1,#2}}[%
  meaning=zero-Bessel-Y-Weber, om=DLMF_BS_z:zBessely,
  params={\nu}{m},
  signature={\Reals\times\posIntegers\mapsto\Reals},
  description={the $m$\textsuperscript{th} zero of the Bessel function
     of the second kind $\BesselY{\nu}$},%     $\zBessely{\nu}{m}$},
  sortkey={y 0 1 zz},
  ]{0}
\defSpecFun{zderivBesselj}[2]{{j'_{#1,#2}}}[%
  meaning=zero-derivative-Bessel-J, om=DLMF_BS_z:zderivBesselj,
  params={\nu}{m},
  signature={\Reals\times\posIntegers\mapsto\Reals},
  description={the $m$\textsuperscript{th} zero of the derivative of the Bessel
     function of the first kind $\BesselJ{\nu}'$},% $\zderivBesselj{\nu}{m}$},  
  sortkey={j 0 3 zz z},
  ]{0}
\defSpecFun{zderivBessely}[2]{{y'_{#1,#2}}}[%
  meaning=zero-derivative-Bessel-Y-Weber, om=DLMF_BS_z:zderivBessely,
  params={\nu}{m},
  signature={\Reals\times\posIntegers\mapsto\Reals},
  description={the $m$\textsuperscript{th} zero of the derivative of the Bessel
     function of the second kind $\BesselY{\nu}'$},% $\zderivBessely{\nu}{m}$},  
  sortkey={y 0 3 zz z},
  ]{0}
\defSpecFun{BesselJimag}[1]{\widetilde{J}_{#1}}[%
  meaning=Bessel-J-imaginary-order, om=DLMF_BS_aux:BesselJimag,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Reals},
  description={the Bessel function of the first kind of imaginary order},% $\BesselJimag{\nu}$},
  sortkey={J 1 3 z - z},
  ]{1}
\defSpecFun{BesselYimag}[1]{\widetilde{Y}_{#1}}[%
  meaning=Bessel-Y-Weber-imaginary-order, om=DLMF_BS_aux:BesselYimag,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Reals},
  description={the Bessel function of the second kind of imaginary order},% $\BesselYimag{\nu}$},
  sortkey={Y 1 3 z - z},
  ]{1}
\defSpecFun{NeumannpolyO}[1]{O_{#1}}[%
  meaning=Neumann-polynomial, om=DLMF_BS_aux:NeumannpolyQ,
  params={n}, args={x},
  signature={\posIntegers\times\Reals\mapsto\Reals},
  description={Neumann's polynomial},% $\NeumannpolyO{n}$},
  sortkey={O 1 1 z z},
  ]{1}
\defSpecFun{Rayleighsigma}[1]{\sigma_{#1}}[%
  meaning=Rayleigh-function, om=DLMF_BS_aux:Rayleighsigma,
  params={n}, args={\nu},
  signature={\posIntegers\times\Reals\mapsto\Reals},
  description={the Rayleigh function},% $\Rayleighsigma{n}$},
  sortkey={sigma 1 1 z z},
  ]{1}

% Modified Bessel Functions
\defSpecFun{modBesselI}[1]{I_{#1}}[%
  meaning=modified-Bessel-first-kind, om=DLMF_BS_mod:modBesselI,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the modified Bessel function of the first kind},% $\modBesselI{\nu}$},
  sortkey={I 1 1 z z},
  ]{1}
\defSpecFun{modBesselK}[1]{K_{#1}}[%
  meaning=modified-Bessel-second-kind, om=DLMF_BS_mod:modBesselK,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the modified Bessel function of the second kind},% $\modBesselK{\nu}$},
  sortkey={K 1 1 z z},
  ]{1}
\defSpecFun{modcylinder}[1]{\mathscr{Z}_{#1}}[%
  meaning=modified-cylinder-function, om=DLMF_BS_mod:modcylinder,
  params={\nu}, args={z},
  signature={\Complexes\times\Complexes\mapsto\Complexes},
  description={the modified cylinder function},% $\modcylinder{\nu}$}, 
  sortkey={Z 1 1 z z},
  ]{1}
\defSpecFun{BickleyKi}[1]{\mathrm{Ki}_{#1}}[%
  meaning=Bickley-Ki, om=DLMF_BS_aux:BickleyKi,
  params={\alpha}, args={x},
  signature={\Complexes\times\Reals\mapsto\Complexes},
  description={the Bickley function},% $\BickleyKi{\alpha}$},
  sortkey={Ki 1 1 z z},
  ]{1}
\defSpecFun{modBesselIimag}[1]{\widetilde{I}_{#1}}[%
  meaning=modified-Bessel-first-kind-imaginary-order, om=DLMF_BS_aux:modBesselIimag,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Reals},
  description={the modified Bessel function of the first kind of imaginary order},
%          $\modBesselIimag{\nu}$},
  sortkey={I 1 3 z - z},
  ]{1}
\defSpecFun{modBesselKimag}[1]{\widetilde{K}_{#1}}[%
  meaning=modified-Bessel-second-kind-imaginary-order, om=DLMF_BS_aux:modBesselKimag,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Reals},
  description={the modified Bessel function of the second kind of imaginary order},
%                   $\modBesselKimag{\nu}$},
  sortkey={K 1 1 z z},
  ]{1}

\defSpecFun{genBesselphi}{\phi}[%
  meaning=generalized-Bessel-function, om=DLMF_BS_gen:genBesselphi,
  args={\rho}{\beta}{z},
  signature={\Complexes\times\Complexes\times\Complexes\mapsto\Complexes},
  description={the generalized Bessel function},% $\genBesselphi$},
  sortkey={phi 3 0 z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]

% Spherical Bessel Functions
\defSpecFun{sphBesselJ}[1]{\mathsf{j}_{#1}}[%
  meaning=spherical-Bessel-J, om=DLMF_BS_sph:sphBesselJ,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the spherical Bessel function of the first kind},% $\sphBesselJ{n}$},
  sortkey={j 1 1 z z},
  ]{1}
\defSpecFun{sphBesselY}[1]{\mathsf{y}_{#1}}[%
  meaning=spherical-Bessel-Y, om=DLMF_BS_sph:sphBesselY,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the spherical Bessel function of the second kind},% $\sphBesselY{n}$},
  sortkey={y 1 1 z z},
  ]{1}
\defSpecFun{sphHankelh}[2]{{\mathsf{h}^{(#1)}_{#2}}}[% Stub for indexed defns
  meaning=spherical-Hankel-H-Bessel-third-kind, om=DLMF_BS_sph:sphHankelh,
  params={i}{n},
  description={placekeeper for indexed spherical Hankel functions},
  ]{0}%
\defSpecFun{sphHankelh{1}}[1]{{\mathsf{h}^{(1)}_{#1}}}[%
  meaning=spherical-Hankel-H-1-Bessel-third-kind, om=DLMF_BS_sph:sphHankelh1,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the spherical Hankel function of the first kind},% $\sphHankelh{1}{n}$},
  sortkey={h 1 3 z 1 z},
  ]{1}
\defSpecFun{sphHankelh{2}}[1]{{\mathsf{h}^{(2)}_{#1}}}[%
  meaning=spherical-Hankel-H-2-Bessel-third-kind, om=DLMF_BS_sph:sphHankel2,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the spherical Hankel function of the second kind},% $\sphHankelh{2}{n}$},
  sortkey={h 1 3 z 2 z},
  ]{1}
\defSpecFun{modsphBesseli}[2]{{\mathsf{i}^{(#1)}_{#2}}}[% Stub for indexed defns
  meaning=spherical-Bessel-I, % om=DLMF_BS_sphmod:modsphBesseli,
  params={i}{n},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={placekeeper for indexed modified spherical Bessel functions},
  ]{0}%
\defSpecFun{modsphBesseli{1}}[1]{{\mathsf{i}^{(1)}_{#1}}}[%
  meaning=spherical-Bessel-I-1, om=DLMF_BS_modsph:modsphBesseli1,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the modified spherical Bessel function $\modsphBesseli{1}{n}$},
  sortkey={i 1 3 z 1 z},
  ]{1}
\defSpecFun{modsphBesseli{2}}[1]{{\mathsf{i}^{(2)}_{#1}}}[%
  meaning=spherical-Bessel-I-2, om=DLMF_BS_modsph:modsphBesseli2,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the modified spherical Bessel function $\modsphBesseli{2}{n}$},
  sortkey={i 1 3 z 2 z},
  ]{1}
\defSpecFun{modsphBesselK}[1]{\mathsf{k}_{#1}}[%
  meaning=spherical-Bessel-K, om=DLMF_BS_modsph:modsphBesselK,
  params={n}, args={z},
  signature={\nonnegIntegers\times\Complexes\mapsto\Complexes},
  description={the modified spherical Bessel function $\modsphBesselK{n}$},
  sortkey={k 1 1 z z},
  ]{1}

% Kelvin functions
\defSpecFun{Kelvinber}[1]{\operatorname{ber}_{#1}}[%
  meaning=Kelvin-ber, om=DLMF_BS_kel:Kelvinber,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Complexes},
  description={the Kelvin function $\Kelvinber{\nu}$},
  sortkey={ber 1 1 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Kelvinbei}[1]{\operatorname{bei}_{#1}}[%
  meaning=Kelvin-bei, om=DLMF_BS_kel:Kelvinbei,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Complexes},
  description={the Kelvin function $\Kelvinbei{\nu}$},
  sortkey={bei 1 1 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Kelvinker}[1]{\operatorname{ker}_{#1}}[%
  meaning=Kelvin-ker, om=DLMF_BS_kel:Kelvinker,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Complexes},
  description={the Kelvin function $\Kelvinker{\nu}$},
  sortkey={ker 1 1 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{Kelvinkei}[1]{\operatorname{kei}_{#1}}[%
  meaning=Kelvin-kei, om=DLMF_BS_kel:Kelvinkei,
  params={\nu}, args={x},
  signature={\Reals\times\Reals\mapsto\Complexes},
  description={the Kelvin function $\Kelvinkei{\nu}$},
  sortkey={kei 1 1 z z},
  ]{1}[\mleft(#1\mright)][#1]
\defSpecFun{MittagLefflerE}[2]{E_{#1,#2}}[%
  meaning=Mittag-Leffler-function, om=DLMF_BS_gen:MittagLefflerE,
  params={a}{b}, args={z},
  signature={\Complexes\times\Complexes\times\Complexes\mapsto\Complexes},
  description={the Mittag-Leffler function},% $\MittagLefflerE{a}{b}$},
  sortkey={E 1 1 zz z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 11 Struve and Related Functions

% Struve
\defSpecFun{StruveH}[1]{\mathbf{H}_{#1}}[%
  meaning=Struve-H, om=DLMF_ST:StruveH,
  params={\nu}, args={z},
  description={the Struve function $\StruveH{\nu}$},
  sortkey={H 1 1 z z},
  ]{1}
\defSpecFun{modStruveL}[1]{\mathbf{L}_{#1}}[%
  meaning=modified-Struve-L, om=DLMF_ST:modStruveL,
  params={\nu}, args={z},
  description={the modified Struve function $\modStruveL{\nu}$},
  sortkey={L 1 1 z z},
  ]{1}
\defSpecFun{StruveK}[1]{\mathbf{K}_{#1}}[%
  meaning=associated-Struve-K, om=DLMF_ST:StruveK,
  params={\nu}, args={z},
  description={the Struve function $\StruveK{\nu}$},
  sortkey={K 1 1 z z},
  ]{1}
\defSpecFun{modStruveM}[1]{\mathbf{M}_{#1}}[%
  meaning=associated-Struve-M, om=DLMF_ST:modStriveM, % Q: mod or ass????
  params={\nu}, args={z},
  description={the modified Struve function $\modStruveM{\nu}$},
  sortkey={M 1 1 z z},
  ]{1}
% Lommel
\defSpecFun{Lommels}[2]{s_{{#1},{#2}}}[%
  meaning=Lommel-s, om=DLMF_ST_lommel:Lommels,
  params={\mu}{\nu}, args={z},
  description={the Lommel function $\Lommels{\mu}{\nu}$},
  sortkey={s 1 1 zz z},
  ]{1}
\defSpecFun{LommelS}[2]{S_{{#1},{#2}}}[%
  meaning=Lommel-S, om=DLMF_ST_lommel:LommelS,
  params={\mu}{\nu}, args={z},
  description={the Lommel function $\LommelS{\mu}{\nu}$},
  sortkey={S 1 1 zz z},
  ]{1}
% Anger, Weber
\defSpecFun{AngerJ}[1]{\mathbf{J}_{#1}}[%
  meaning=Anger-J, om=DLMF_ST:AngerJ,
  params={\nu}, args={z},
  description={the Anger function},% $\AngerJ{\nu}$},
  sortkey={J 1 1 z z},
  ]{1}
\defSpecFun{WeberE}[1]{\mathbf{E}_{#1}}[%
  meaning=Weber-E, om=DLMF_ST:WeberE,
  params={\nu}, args={z},
  description={the Weber function},% $\WeberE{\nu}$},
  sortkey={E 1 1 z z},
  ]{1}
\defSpecFun{AngerWeberA}[1]{\mathbf{A}_{#1}}[%
  meaning=associated-Anger-Weber-A, om=DLMF_ST:AngerWeberA,
  params={\nu}, args={z},
  description={the Anger--Weber function},% $\AngerWeberA{\nu}$},
  sortkey={A 1 1 z z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 12 Parabolic Cylinder Functions
\defSpecFun{WhittakerparaD}[1]{D_{#1}}[%
  meaning=Whittaker-D, om=parabolic1_dlmf:D,
  params={\nu}, args={z},
  description={Whittaker's notation for the parabolic cylinder function},% $\WhittakerparaD{\nu}$},
  sortkey={D 1 1 z z},
  ]{1}
\defSpecFun{paraU}{U}[%
  meaning=parabolic-U, om=parabolic1_dlmf:U,
  args={a}{z},
  description={the parabolic cylinder (or Weber) function $\paraU$},
  sortkey={U 2 0 z z},
  ]{2}
\defSpecFun{paraV}{V}[%
  meaning=parabolic-V, om=parabolic1_dlmf:V,
  args={a}{z},
  description={the parabolic cylinder (or Weber) function $\paraV$},
  sortkey={V 2 0 z z},
  ]{2}
\defSpecFun{paraUbar}{\overline{U}}[%
  meaning=parabolic-U-bar, om=parabolic2_dlmf:U_real,
  args={a}{x},
  description={the parabolic cylinder (or Weber) function $\paraUbar$},
  sortkey={U 2 2 - z z},
  ]{2}
\defSpecFun{paraW}{W}[%
  meaning=parabolic-W, om=parabolic1_dlmf:W,
  args={a}{x},
  description={the parabolic cylinder (or Weber) function $\paraW$},
  sortkey={W 2 0 z z},
  ]{2}
% Defined in parabolic, but should be here.
\defSpecFun{envparaU}{\mathrm{env}\mskip-1mu\relax U}[%
  meaning=envelope-Parabolic-U, om=parabolic2_dlmf:env_U,
  args={c}{x},
  description={the envelope of the parabolic cylinder function $\paraU$},% $\envparaU$},
  sortkey={envU 2 0 z z},
  ]{2}
\defSpecFun{envparaUbar}{\mathrm{env}\mskip-1mu\relax \overline{U}}[%
  meaning=envelope-Parabolic-U-bar, om=parabolic2_dlmf:env_U_real,
  args={c}{x},
  description={the envelope of the parabolic cylinder function $\paraUbar$},% $\envparaUbar$},
  sortkey={envU 2 2 - z z},
  ]{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 13 Confluent Hypergeometric Functions
\defSpecFun{KummerconfhyperM}{M}[%
  meaning=Kummer-confluent-hypergeometric-M, om=hypergeo1:hypergeometric1F1, % Is this correct?
  args={a}{b}{z},
  description={the Kummer confluent hypergeometric function $\KummerconfhyperM$},
  sortkey={M 3 0 z z z},
  ]{3}
\defSpecFun{OlverconfhyperM}{{\mathbf{M}}}[%
  meaning=Kummer-confluent-hypergeometric-bold-M, om=hypergeo3_dlmf:Olver_M,
  args={a}{b}{z},
  description={Olver's confluent hypergeometric function},% $\OlverconfhyperM$},
  sortkey={M 3 0 z z z},
  ]{3}
\defSpecFun{KummerconfhyperU}{U}[%
  meaning=Kummer-confluent-hypergeometric-U, om=hypergeo3_dlmf:Kummer_U,
  args={a}{b}{z},
  description={the Kummer confluent hypergeometric function $\KummerconfhyperU$},
  sortkey={U 3 0 z z z},
  ]{3}
\defSpecFun{WhittakerconfhyperM}[2]{M_{#1,#2}}[%
  meaning=Whittaker-confluent-hypergeometric-M, om=hypergeo3_dlmf:Whittaker_M,
  params={\kappa}{\mu},args={z},
  description={the Whittaker confluent hypergeometric function $\WhittakerconfhyperM{\kappa}{\mu}$},
  sortkey={M 1 1 zz z},
  ]{1}
\defSpecFun{WhittakerconfhyperW}[2]{W_{#1,#2}}[%
  meaning=Whittaker-confluent-hypergeometric-W, om=hypergeo3_dlmf:Whittaker_W,
  params={\kappa}{\mu},args={z},
  description={the Whittaker confluent hypergeometric function $\WhittakerconfhyperW{\kappa}{\mu}$},
  sortkey={W 1 1 zz z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 14 Legendre and Related Functions
\defSpecFun{FerrersP}[2][]{\mathsf{P}\ifx.#1.\else^{#1}\fi_{#2}}[%
  meaning=Ferrers-Legendre-P-first-kind, om=legendrefun1_dlmf:Ferrers_P,
  params={\mu}{\nu}, args={x},
  description={the Ferrers function of the first kind},% $\FerrersP[\mu]{\nu}$},
  sortkey={P 1 3 z z z},
  ]{1}
\defSpecFun{FerrersP[]}[1]{\mathsf{P}_{#1}}[%
  meaning=shorthand-Ferrers-Legendre-P-first-kind, om=legendrefun1_dlmf:Ferrers_P,
  params={\nu}, args={x},
  description={$=\FerrersP[0]{\nu}$, shorthand for the Ferrers function of the first kind},
  sortkey={P 1 3 z z z},
  ]{1}
\defSpecFun{FerrersQ}[2][]{\mathsf{Q}\ifx.#1.\else^{#1}\fi_{#2}}[%
  meaning=Ferrers-Legendre-Q-first-kind, om=legendrefun1_dlmf:Ferrers_Q,
  params={\mu}{\nu}, args={x},
  description={the Ferrers function of the second kind},% $\FerrersQ[\mu]{\nu}$},
  sortkey={Q 1 3 z z z},
  ]{1}
\defSpecFun{FerrersQ[]}[1]{\mathsf{Q}_{#1}}[%
  meaning=shorthand-Ferrers-Legendre-Q-first-kind, om=legendrefun1_dlmf:Ferrers_Q,
  params={\nu}, args={x},
  description={$=\FerrersQ[0]{\nu}$, shorthand for the Ferrers function of the second kind},
  sortkey={Q 1 3 z z z},
  ]{1}
\defSpecFun{assLegendreP}[2][]{P\ifx.#1.\else^{#1}\fi_{#2}}[%
  meaning=Legendre-P-first-kind, om=legendrefun1_dlmf:Legendre_P,
  params={\mu}{\nu}, args={z},
  description={the associated Legendre function of the first kind},% $\assLegendreP[\mu]{\nu}$},
  sortkey={P 1 3 z z z},
  ]{1}
\defSpecFun{assLegendreP[]}[1]{P_{#1}}[%
  meaning=shorthand-Legendre-P-first-kind, om=legendrefun1_dlmf:Legendre_P,
  params={\nu}, args={z},
  description={$=\assLegendreP[0]{\nu}$, shorthand for the associated Legendre function of the first kind},
  sortkey={P 1 1 z z},
  ]{1}
\defSpecFun{assLegendreQ}[2][]{Q\ifx.#1.\else^{#1}\fi_{#2}}[%
  meaning=Legendre-Q-second-kind, om=legendrefun1_dlmf:Legendre_Q,
  params={\mu}{\nu}, args={z},
  description={the associated Legendre function of the second kind},% $\assLegendreQ[\mu]{\nu}$},
  sortkey={Q 1 3 z z z},
  ]{1}
\defSpecFun{assLegendreQ[]}[1]{Q_{#1}}[%
  meaning=shorthand-Legendre-Q-second-kind, om=legendrefun1_dlmf:Legendre_Q,
  params={\nu}, args={z},
  description={$=\assLegendreQ[0]{\nu}$, shorthand for the associated Legendre function of the second kind},
  sortkey={Q 1 1 z z},
  ]{1}
\defSpecFun{assLegendreOlverQ}[2][]{\boldsymbol{Q}\ifx.#1.\else^{#1}\fi_{#2}}[%
  meaning=associated-Legendre-black-Q, om=legendrefun1_dlmf:Olver_Q,
  params={\mu}{\nu}, args={z},
  description={Olver's associated Legendre function},% $\assLegendreOlverQ[\mu]{\nu}$},
  sortkey={Q 1 3 z z z},
  ]{1}
\defSpecFun{assLegendreOlverQ[]}[1]{\boldsymbol{Q}_{#1}}[%
  meaning=shorthand-associated-Legendre-black-Q, om=legendrefun1_dlmf:Olver_Q,
  params={\nu}, args={z},
  description={$=\assLegendreOlverQ[0]{\nu}$, shorthand for Olver's associated Legendre function},
  sortkey={Q 1 1 z z},
  ]{1}
\defSpecFun{DunsterQ}[2]{\widehat{\mathsf{Q}}^{#1}_{#2}}[%
  meaning=Ferrers-conical-legendre-Q-hat, om=legendrefun1_dlmf:Dunster_Q,
  params={-\mu}{-\tfrac{1}{2}+\iunit\tau}, args={x},
  description={Dunster's conical function},% $\DunsterQ[-\mu]{-1/2+i\tau}$},
  sortkey={Q 1 3 z zz z},
  ]{1}
\defSpecFun{sphharmonicY}[2]{Y_{{#1},{#2}}}[%
  meaning=spherical-harmonic-Y, om=legendrefun1_dlmf:spherical_harmonic,
  params={l}{m}, args={\theta}{\phi},
  description={the spherical harmonic},% $\sphharmonicY{l}{m}$},
  sortkey={Y 2 1 zz z z},
  ]{2}
\defSpecFun{surfharmonicY}[2]{Y_{#1}^{#2}}[%
  meaning=surface-harmonic-Y, om=legendrefun1_dlmf:surface_harmonic,
  params={l}{m}, args={\theta}{\phi},
  description={the surface harmonic of the first kind},% $\surfharmonicY{l}{m}$},
  sortkey={Y 2 3 z z z z},
  ]{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 15 Hypergeometric Function
\defSpecFun{hyperF}{F}[%
  meaning=Gauss-hypergeometric-F, om=hypergeo1:hypergeometric2F1,
  args={a}{b}{c}{z},
  description={(Gauss') hypergeometric function},% $\hyperF$},
  sortkey={F 4 0 z z z z},
  ]{4}[\mleft(#1,#2;#3;#4\mright)][\mleft({#1, #2 \atop #3};#4\mright)][\mleft(#4\mright)]
\defSpecFun{hyperOlverF}{\mathbf{F}}[%
  meaning=scaled-hypergeometric-bold-F, om=hypergeo3_dlmf:Olver_F,
  args={a}{b}{c}{z},
  description={Olver's scaled hypergeometric function},% $\hyperOlverF$},
  sortkey={F 4 0 z z z z},
  ]{4}[\mleft(#1,#2;#3;#4\mright)][\mleft({#1, #2 \atop #3};#4\mright)][\mleft(#4\mright)]
\defSpecFun{Jacobiphi}[3]{\phi^{(#1,#2)}_{#3}}[%
  meaning=Jacobi-hypergeometric-phi, om=hypergeo3_dlmf:Jacobi_phi,
  params={\alpha}{\beta}{\lambda}, args={t},
  description={the Jacobi function},% $\Jacobiphi{\alpha}{\beta}{\lambda}$},
  sortkey={phi 1 3 z zz z},
  ]{1}
%%\defSpecFun{JacobiPhi}[3]{\Phi^{(#1,#2)}_{#3}}[%
%%  meaning=Jacobi-hypergeometric-Phi, om=HY1_dlmf,
%%  ]{1}
\defSpecFun{RiemannsymP}{P}[%
  meaning=Riemann-P-symbol,role=OPFUNCTION, om=hypergeo3_dlmf:Riemann_P,
%  args={\begin{Bmatrix} \alpha & \beta &\gamma & \\ a_1 & b_1 & c_1 & z \\ a_2 & b_2 & c_2 & \end{Bmatrix}},
  args={\begin{Bmatrix} a & b & c & \cr a_1 & b_1 & c_1 & z \cr a_2 & b_2 & c_2 & \end{Bmatrix}},  
  description={Riemann's $\RiemannsymP$-symbol for solutions of the generalized hypergeometric differential equation},
  sortkey={P 1 zzz},
  ]{1}[#1]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 16 Generalized Hypergeometric Functions & Meijer G-Function
\defSpecFun{genhyperOlverF}[2]{{{}_{#1}{\mathbf{F}}_{#2}}}[%
  meaning=hypergeometric-bold-pFq, om=hypergeo4_dlmf:Olver_hypergeometric_pFq,
  params={p}{q}, args={a_1,\dots,a_p}{b_1,\dots,b_q}{z},
  description={Olver's scaled generalized hypergeometric function},% $\genhyperOlverF{p}{q}$},
  sortkey={F 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]
\defSpecFun{genhyperF}[2]{{{}_{#1}F_{#2}}}[%
  meaning=Gauss-hypergeometric-pFq, om=hypergeo1:hypergeometric_pFq,
  params={p}{q}, args={a_1,\dots,a_p}{b_1,\dots,b_q}{z},
  description={the generalized hypergeometric function},% $\genhyperF{p}{q}$},
  sortkey={F 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]
\defSpecFun{genhyperF{1}{1}}{{{}_{1}F_{1}}}[%
  meaning=Kummer-confluent-hypergeometric-M-as-1F1, om=hypergeo1:hypergeometric1F1, % Is this correct?
  args={a}{b}{z},
  description={Kummer confluent hypergeometric function, $\genhyperF{1}{1} = \KummerconfhyperM$},
  sortkey={F 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]
\defSpecFun{genhyperF{2}{1}}{{{}_{2}F_{1}}}[%
  meaning=Gauss-hypergeometric-F-as-2F1, om=hypergeo1:hypergeometric2F1,
  args={a,b}{c}{z},
  description={Gauss' hypergeometric function, $\genhyperF{2}{1} = \hyperF$},
  sortkey={F 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]

\defSpecFun{genhyperH}[2]{{{}_{#1}H_{#2}}}[%
  meaning=hypergeometric-pHq, om=hypergeo4_dlmf:hypergeometric_pHq,
  params={p}{q}, args={a_1,\dots,a_p}{b_1,\dots,b_q}{z},
  description={the bilateral hypergeometric function},% $\genhyperH{p}{q}$},
  sortkey={H 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]
% Stub, so indexed definitions take effect
\defSpecFun{AppellF}[1]{{F_{#1}}}[%
  meaning=Appell-F, % role=OPFUNCTION, om=hypergeon3:appel_F, % One "l" ???
  params={i}, description={placekeeper for indexed Appell functions},
  ]{0}%
\defSpecFun{AppellF{1}}{{F_{1}}}[%
  meaning=Appell-F-1, om=hypergeon2:appel_F1, % One "l" ???
  args={\alpha}{\beta}{\beta'}{\gamma}{x}{y},
  description={the first Appell function},% $\AppellF{1}$},
  sortkey={F 6 1 1 z z z z z z}, % lie about # args!
  ]{6}[\mleft(#1;#2,#3;#4;#5,#6\mright)]
\defSpecFun{AppellF{2}}{{F_{2}}}[%
  meaning=Appell-F-2, om=hypergeon2:appel_F2,
  args={\alpha}{\beta}{\beta'}{\gamma}{\gamma'}{x}{y},
  description={the second Appell function},% $\AppellF{2}$},
  sortkey={F 6 1 2 z z z z z z}, % lie about # args!
  ]{7}[\mleft(#1;#2,#3;#4,#5;#6,#7\mright)]
\defSpecFun{AppellF{3}}{{F_{3}}}[%
  meaning=Appell-F-3, om=hypergeon2:appel_F3,
  args={\alpha}{\alpha'}{\beta}{\beta'}{\gamma}{x}{y},
  description={the third Appell function},% $\AppellF{3}$},
  sortkey={F 6 1 3 z z z z z z}, % lie about # args!
  ]{7}[\mleft(#1,#2;#3,#4;#5;#6,#7\mright)]
\defSpecFun{AppellF{4}}{{F_{4}}}[%
  meaning=Appell-F-4, om=hypergeon2:appel_F4,
  args={\alpha}{\beta}{\gamma}{\gamma'}{x}{y},
  description={the fourth Appell function},% $\AppellF{4}$},
  sortkey={F 6 1 4 z z z z z z}, % lie about # args!
  ]{6}[\mleft(#1,#2;#3,#4;#5,#6\mright)]
\defSpecFun{MeijerG}[4]{{G^{#1,#2}_{#3,#4}}}[%
  meaning=Meijer-G, om=hypergeo4_dlmf:Meijer_G,
  params={m}{n}{p}{q}, args={z}{a_1\dots,a_p}{b_1,\dots,b_q},
  description={the Meijer $G$-function},
  sortkey={G 3 3 zz zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft(#1;{#2 \atop #3}\mright)][\mleft(#1\mright)]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 17 q-Hypergeometric and Related Functions
\defSpecFun{idem}{\mathrm{idem}}[%
  meaning=idem, om=qfunctions1_dlmf:idem,
  args={\chi_1}{\chi_2\dots\chi_n},
  description={the idem function},% $\idem$},
  sortkey={item 1 z},
  ]{2}[\mleft(#1;#2\mright)]
% Contrived to make !_q the postfix operator, rather than !, and avoid mentioning normal factorial
%\defSpecFun{qfactorial}[2]{#1!_{#2}}[
\lxDefMath{\@nonfactorial}{!}[role=POSTFIX,alias=!,meaning=]%
\defSpecFun{qfactorial}[2]{#1\lxMathTweak{role=POSTFIX}{\@nonfactorial_{#2}}}[
  meaning=q-factorial, om=qfunctions1_dlmf:q-factorial,
  params={n}{q},
  description={the $q$-factorial},% $\qfactorial{n}{q}$},
  sortkey={*a! 0 1 q},
 ]{0}
\defSpecFun{qbinom}[3]{\genfrac[]\z@{}{#1}{#2}_{#3}}[
  meaning=q-binomial, om=qfunctions1_dlmf:q-binomial,
  params={n}{m}{q},
  description={the $q$-binomial coefficient},% $\qbinom{n}{m}{q}$},
  sortkey={*n[[ 2 1 q z z},
 ]{0}
% similar, but 1st argument is n-ary
\defSpecFun{qmultinomial}[3]{\genfrac[]\z@{}{#1}{#2}_{#3}}[
  meaning=q-multinomial, om=qfunctions1_dlmf:q-multinomial,
  params={n}{n_1,n_2,\ldots,n_3}{q},
%   params={n}{n_1,n_2,...,n_3}{q},
  description={the $q$-multinomial coefficient},% $\qmultinomial{n}{n_1,n_2,\ldots,n_3}{q}$},
  sortkey={*n[[ 2 1 q z z},
 ]{0}
\defSpecFun{qPochhammer}[3]{\mleft(#1;#2\mright)_{#3}}[
  meaning=q-Pochhammer, om=qfunctions1_dlmf:q-Pochhammer,
  params={a}{q}{n},
  description={the $q$-Pochhammer symbol (or $q$-shifted factorial)},% $\qPochhammer{a}{q}{n}$},
  sortkey={*p( 2 1 z z z},
 ]{0}
% similar, but 1st argument is n-ary (it is a product of qPochhammers)
\defSpecFun{qmultiPochhammersym}[3]{\mleft(#1;#2\mright)_{#3}}[
  meaning=q-multiple-Pochhammer, om=qfunctions1_dlmf:q-multi-Pochhammer,
  params={a_1,a_2,\ldots,a_k}{q}{n},
  description={the $q$-multiple Pochhammer symbol},% $\qmultiPochhammersym{a_1,a_2,\ldots,a_k}{q}{n}$},
  sortkey={*p( 2 1 zz z z},  
 ]{0}
\defSpecFun{qexp}[1]{e_{#1}}[%
  meaning=q-exp, om=qfunctions1_dlmf:q-exp,
  params={q}, args={x},
  description={the $q$-exponential function $\qexp{q}$},
  sortkey={e 1 1 q z},
  ]{1}
\defSpecFun{qExp}[1]{E_{#1}}[%
  meaning=q-Exp, om=qfunctions1_dlmf:q-Exp,
  params={q}, args={x},
  description={the $q$-exponential function $\qExp{q}$},
  sortkey={E 1 1 q z},
  ]{1}
\defSpecFun{qsin}[1]{\mathrm{sin}_{#1}}[%
  meaning=q-sin, om=qfunctions1_dlmf:q-sin,
  params={q}, args={x},
  description={the $q$-sine function $\qsin{q}$},
  sortkey={sin 1 1 q z},
  ]{1}
\defSpecFun{qSin}[1]{\mathrm{Sin}_{#1}}[%
  meaning=q-Sin, om=qfunctions1_dlmf:q-Sin,
  params={q}, args={x},
  description={the $q$-sine function $\qSin{q}$},
  sortkey={Sin 1 1 q z},
  ]{1}
\defSpecFun{qcos}[1]{\mathrm{cos}_{#1}}[%
  meaning=q-cos, om=qfunctions1_dlmf:q-cos,
  params={q}, args={x},
  description={the $q$-cosine function $\qcos{q}$},
  sortkey={cos 1 1 q z},
  ]{1}
\defSpecFun{qCos}[1]{\mathrm{Cos}_{#1}}[%
  meaning=q-Cos, om=qfunctions1_dlmf:q-Cos,
  params={q}, args={x},
  description={the $q$-cosine function $\qCos{q}$},
  sortkey={Cos 1 1 q z},
  ]{1}
\defSpecFun{qBernoullipolybeta}[1]{\beta_{#1}}[%
  meaning=q-Bernoulli-polynomial, om=qfunctions1_dlmf:q-Bernoulli,
  params={n}, args={x}{q},
  description={the $q$-Bernoulli polynomial},% $\qBernoullipolybeta{n}$},
  sortkey={beta 2 1 z z q},
  ]{2}
\defSpecFun{qEulernumberA}[2]{A_{#1,#2}}[%
  meaning=q-Euler-number, om=qfunctions1_dlmf:q-Euler,
  params={m}{s}, args={q},
  description={the $q$-Euler number},% $\qEulernumberA{m}{s}$},
  sortkey={A 1 1 zz q},
  ]{1}
\defSpecFun{qStirlingnumbera}[2]{a_{#1,#2}}[%
  meaning=q-Stirling-number, om=qfunctions1_dlmf:q-Stirling,
  params={m}{s}, args={q},
  description={the $q$-Stirling number},% $\qStirlingnumbera{m}{s}$},
  sortkey={a 1 1 zz q},
  ]{1}
\defSpecFun{qgenhyperphi}[2]{{{}_{#1}\phi_{#2}}}[%
  meaning=q-hypergeometric-rphis, om=qfunctions1_dlmf:q-hypergeometric_phi,
  params={r+1}{s}, args={a_0,\dots,a_r}{b_1,\dots,b_s}{q}{z},
  description={the $q$-hypergeometric (or basic hypergeometric) function},
  %   $\qgenhyperphi{r+1}{s}$},
  sortkey={phi 4 1 zz z z z z},
  ]{4}[\mleft(#1;#2;#3,#4\mright)][\mleft({#1 \atop #2};#3,#4\mright)][\mleft(#3,#4\mright)]
\defSpecFun{qgenhyperpsi}[2]{{{}_{#1}\psi_{#2}}}[%
  meaning=q-hypergeometric-rpsis, om=qfunctions1_dlmf:q-hypergeometric-psi,
  params={r}{s}, args={a_0,\dots,a_r}{b_1,\dots,b_s}{q}{z},
  description={the bilateral $q$-hypergeometric (or bilateral basic hypergeometric) function},
  %  $\qgenhyperpsi{r}{s}$},
  sortkey={psi 4 1 zz z z z z},
  ]{4}[\mleft(#1;#2;#3,#4\mright)][\mleft({#1 \atop #2};#3,#4\mright)][\mleft(#3,#4\mright)]
% Stub, so indexed definitions take effect
\defSpecFun{qAppellPhi}[1]{\Phi^{(#1)}}[%
  meaning=q-Appell-F, % om=hypergeon2:appel_F1, % One "l" ???
  params={i}, description={placekeeper for the indexed $q$-Appell functions},
  ]{0}%
\defSpecFun{qAppellPhi{1}}{\Phi^{(1)}}[%
  meaning=q-Appell-Phi-1, om=qfunctions1_dlmf:q-Appell_F1,
  args={a}{b}{b'}{c}{q}{x}{y},
  description={the first $q$-Appell function},% $\qAppellPhi{1}$},
  sortkey={Phi 5 1 1 z z z z q},
  ]{7}[\mleft(#1;#2,#3;#4;#5;#6,#7\mright)]
\defSpecFun{qAppellPhi{2}}{\Phi^{(2)}}[%
  meaning=q-Appell-Phi-2, om=qfunctions1_dlmf:q-Appell_F2,
  args={a}{b}{b'}{c}{c'}{q}{x}{y},
  description={the second $q$-Appell function},% $\qAppellPhi{2}$},
  sortkey={Phi 5 1 2 z z z z q},
  ]{8}[\mleft(#1;#2,#3;#4,#5;#6;#7,#8\mright)]
\defSpecFun{qAppellPhi{3}}{\Phi^{(3)}}[%
  meaning=q-Appell-Phi-3, om=qfunctions1_dlmf:q-Appell_F3,
  args={a}{a'}{b}{b'}{c}{q}{x}{y},
  description={the third $q$-Appell function},% $\qAppellPhi{3}$},
  sortkey={Phi 5 1 3 z z z z q},
  ]{8}[\mleft(#1,#2;#3,#4;#5;#6;#7,#8\mright)]
\defSpecFun{qAppellPhi{4}}{\Phi^{(4)}}[%
  meaning=q-Appell-Phi-4, om=qfunctions1_dlmf:q-Appell_F4,
  args={a}{b}{c}{c'}{q}{x}{y},
  description={the fourth $q$-Appell function},% $\qAppellPhi{4}$},
  sortkey={Phi 5 1 4 z z z z q},
  ]{7}[\mleft(#1,#2;#3,#4;#5;#6,#7\mright)]
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 18 Orthogonal Polynomials
% Need to split into multiple CD's ?
\defSpecFun{JacobipolyP}[3]{P^{(#1,#2)}_{#3}}[%
  meaning=Jacobi-polynomial-P, om=orthpoly2_dlmf:Jacobi_P,
  params={\alpha}{\beta}{n}, args={x},
  description={the Jacobi polynomial},% $\JacobipolyP{\alpha}{\beta}{n}$},
  sortkey={P 1 3 z zz z},
  ]{1}
\defSpecFun{ultrasphpoly}[2]{C^{(#1)}_{#2}}[%
  meaning=ultraspherical-Gegenbauer-polynomial, om=orthpoly2_dlmf:ultraspherical,
  params={\lambda}{n}, args={x},
  description={the ultraspherical (or Gegenbauer) polynomial},% $\ultrasphpoly{\lambda}{n}$},
  sortkey={C 1 3 z z z},
  ]{1}
\defSpecFun{ChebyshevpolyT}[1]{T_{#1}}[%
  meaning=Chebyshev-polynomial-first-kind-T, om=orthpoly2_dlmf:Chebyshev_T,
  params={n}, args={x},
  description={the Chebyshev polynomial of the first kind},% $\ChebyshevpolyT{n}$},
  sortkey={T 1 1 z z},
  ]{1}
\defSpecFun{ChebyshevpolyU}[1]{U_{#1}}[%
  meaning=Chebyshev-polynomial-second-kind-U, om=orthpoly2_dlmf:Chebyshev_U,
  params={n}, args={x},
  description={the Chebyshev polynomial of the second kind},% $\ChebyshevpolyU{n}$},
  sortkey={U 1 1 z z},
  ]{1}
\defSpecFun{ChebyshevpolyV}[1]{V_{#1}}[%
  meaning=Chebyshev-polynomial-third-kind-V, om=orthpoly2_dlmf:Chebyshev_V,
  params={n}, args={x},
  description={the Chebyshev polynomial of the third kind},% $\ChebyshevpolyV{n}$},
  sortkey={V 1 1 z z},
  ]{1}
\defSpecFun{ChebyshevpolyW}[1]{W_{#1}}[%
  meaning=Chebyshev-polynomial-fourth-kind-W, om=orthpoly2_dlmf:Chebyshev_W,
  params={n}, args={x},
  description={the Chebyshev polynomial of the fourth kind},% $\ChebyshevpolyW{n}$},
  sortkey={W 1 1 z z},
  ]{1}
\defSpecFun{shiftChebyshevpolyT}[1]{T^{*}_{#1}}[%
  meaning=shifted-Chebyshev-polynomial-first-kind-T-star, om=orthpoly2_dlmf:Chebyshev_T_shifted,
  params={n}, args={x},
  description={the shifted Chebyshev polynomial of the first kind},% $\shiftChebyshevpolyT{n}$},
  sortkey={T 1 3 z * z},
  ]{1}
\defSpecFun{shiftChebyshevpolyU}[1]{U^{*}_{#1}}[%
  meaning=shifted-Chebyshev-polynomial-second-kind-U-star, om=orthpoly2_dlmf:Chebyshev_U_shifted,
  params={n}, args={x},
  description={the shifted Chebyshev polynomial of the second kind},% $\shiftChebyshevpolyU{n}$},
  sortkey={U 1 3 z * z},
  ]{1}
\defSpecFun{LegendrepolyP}[1]{P_{#1}}[%
  meaning=Legendre-spherical-polynomial, om=orthpoly2_dlmf:Legendre_P,
  params={n}, args={x},
  description={the Legendre (or spherical) polynomial},% $\LegendrepolyP{n}$},
  sortkey={P 1 1 z z},
  ]{1}
\defSpecFun{shiftLegendrepolyP}[1]{P^{*}_{#1}}[%
  meaning=shifted-spherical-Legendre-polynomial-s, om=orthpoly2_dlmf:Legendre_P_shifted,
  params={n}, args={x},
  description={the shifted Legendre polynomial},% $\shiftLegendrepolyP{n}$},
  sortkey={P 1 3 z * z},
  ]{1}
% NOTE: Do we need "generalized" here?????
\defSpecFun{LaguerrepolyL}[2][]{L\ifx.#1.\else^{(#1)}\fi_{#2}}[%
  meaning=Laguerre-polynomial-L, om=orthpoly2_dlmf:Laguerre_L,
  params={\alpha}{n}, args={x},
  description={the (generalized or associated) Laguerre (or Sonin) polynomial},% $\LaguerrepolyL[\alpha]{n}$},
  sortkey={L 1 3 z z z},
  ]{1}
\defSpecFun{LaguerrepolyL[]}[1]{L_{#1}}[%
  meaning=shorthand-Laguerre-polynomial-L, om=orthpoly2_dlmf:Laguerre_L,
  params={n}, args={x},
  description={$=\LaguerrepolyL[0]{n}$, shorthand for the Laguerre polynomial},
  sortkey={L 1 3 z z z},
  ]{1}
\defSpecFun{HermitepolyH}[1]{H_{#1}}[%
  meaning=Hermite-polynomial-H, om=orthpoly2_dlmf:Hermite_H,
  params={n}, args={x},
  description={the Hermite polynomial},% $\HermitepolyH{n}$},
  sortkey={H 1 1 z z},
  ]{1}
\defSpecFun{dilHermitepolyHe}[1]{\mathit{He}_{#1}}[%
  meaning=Hermite-polynomial-He, om=orthpoly2_dlmf:Hermite_He,
  params={n}, args={x},
  description={the dilated Hermite polynomial},% $\dilHermitepolyHe{n}$},
  sortkey={He 1 1 z z},
  ]{1}
\defSpecFun{HahnpolyQ}[1]{Q_{#1}}[%
  meaning=Hahn-polynomial-Q, om=orthpoly3_dlmf:Hahn_Q,
  params={n}, args={x}{\alpha}{\beta}{N},
  description={the Hahn polynomial},% $\HahnpolyQ{n}$},
  sortkey={Q 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3,#4\mright)]
\defSpecFun{KrawtchoukpolyK}[1]{K_{#1}}[%
  meaning=Krawtchouk-polynomial-K, om=orthpoly3_dlmf:Krawtchouk,
  params={n}, args={x}{p}{N},
  description={the Krawtchouk polynomial},% $\KrawtchoukpolyK{n}$},
  sortkey={K 3 1 z z z z},
  ]{3}[\mleft(#1;#2,#3\mright)]
\defSpecFun{MeixnerpolyM}[1]{M_{#1}}[%
  meaning=Meixner-polynomial-M, om=orthpoly3_dlmf:Meixner_M,
  params={n}, args={x}{\beta}{c},
  description={the Meixner polynomial},% $\MeixnerpolyM{n}$},
  sortkey={M 3 1 z z z z},
  ]{3}[\mleft(#1;#2,#3\mright)]
\defSpecFun{CharlierpolyC}[1]{C_{#1}}[%
  meaning=Charlier-polynomial-C, om=orthpoly3_dlmf:Charlier_C,
  params={n}, args={x}{a},
  description={the Charlier polynomial},% $\CharlierpolyC{n}$},
  sortkey={C 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{contHahnpolyp}[1]{p_{#1}}[%
  meaning=continuous-Hahn-polynomial-p, om=orthpoly3_dlmf:cont-Hahn_p,
  params={n}, args={x}{a}{b}{\conj{a}}{\conj{b}},
  description={the continuous Hahn polynomial},% $\contHahnpolyp{n}$},
  sortkey={p 5 1 z z z z z},
  ]{5}[\mleft(#1;#2,#3,#4,#5\mright)]
\defSpecFun{MeixnerPollaczekpolyP}[2]{P^{(#1)}_{#2}}[%
  meaning=Meixner-Pollaczek-polynomial-P, om=orthpoly3_dlmf:Meixner-Pollaczek_P,
  params={\lambda}{n}, args={x}{\phi},
  description={the Meixner--Pollaczek polynomial},% $\MeixnerPollaczekpolyP{\lambda}{n}$},
  sortkey={P 2 3 z z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{WilsonpolyW}[1]{W_{#1}}[%
  meaning=Wilson-polynomial-W, om=orthpoly3_dlmf:Wilson_W,
  params={n}, args={x^2}{a}{b}{c}{d},
  description={the Wilson polynomial},% $\WilsonpolyW{n}$},
  sortkey={W 5 1 z z z z z z},
  ]{5}[\mleft(#1;#2,#3,#4,#5\mright)]
\defSpecFun{RacahpolyR}[1]{R_{#1}}[%
  meaning=Racah-polynomial-R, om=orthpoly3_dlmf:Racah_R,
  params={n}, args={x(x+\gamma+\delta+1)}{\alpha}{\beta}{\gamma}{\delta},
  description={the Racah polynomial},% $\RacahpolyR{n}$},
  sortkey={R 5 1 z z z z z z},
  ]{5}[\mleft(#1;#2,#3,#4,#5\mright)]
\defSpecFun{contdualHahnpolyS}[1]{S_{#1}}[%
  meaning=continuous-dual-Hahn-S, om=orthpoly3_dlmf:cont-dual-Hahn_S,
  params={n}, args={x^2}{a}{b}{c},
  description={the continuous dual Hahn polynomial},% $\contdualHahnpolyS{n}$},
  sortkey={S 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3,#4\mright)]
\defSpecFun{dualHahnpolyR}[1]{R_{#1}}[%
  meaning=dual-Hahn-R, om=orthpoly3_dlmf:dual-Hahn_R,
  params={n}, args={x(x+\gamma+\delta+1)}{\gamma}{\delta}{N},
  description={the dual Hahn polynomial},% $\dualHahnpolyR{n}$},
  sortkey={R 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3,#4\mright)]
\defSpecFun{qHahnpolyQ}[1]{Q_{#1}}[%
  meaning=q-Hahn-polynomial-Q, om=orthpoly5_dlmf:q-Hahn_Q,
  params={n}, args={x}{\alpha}{\beta}{N}{q},
  description={the $q$-Hahn polynomial},% $qHahnQ{n}$},
  sortkey={Q 5 1 z z z z z z},
  ]{5}[\mleft(#1;#2,#3,#4;#5\mright)]
\defSpecFun{bigqJacobipolyP}[1]{P_{#1}}[%
  meaning=q-Jacobi-polynomial-P, om=orthpoly5_dlmf:q-Jacobi_P,
  params={n}, args={x}{a}{b}{c}{q},
  description={the big $q$-Jacobi polynomial},% $\bigqJacobipolyP{n}$},
  sortkey={P 5 1 z z z z z z},
  ]{5}[\mleft(#1;#2,#3,#4;#5\mright)]
\defSpecFun{scbigqJacobipolyP}[3]{P^{(#1,#2)}_{#3}}[%
  meaning=big-q-Jacobi-polynomial-P-type-2, om=orthpoly5_dlmf:big-q-Jacobi_P,
  params={\alpha}{\beta}{n}, args={x}{c}{d}{q},
  description={the scaled big $q$-Jacobi polynomial},% $\scbigqJacobipolyP{\alpha}{\beta}{n}$},
  sortkey={P 4 3 zz z z z z z},
  ]{4}[\mleft(#1;#2,#3;#4\mright)]
\defSpecFun{littleqJacobipolyp}[1]{p_{#1}}[%
  meaning=q-Jacobi-polynomial-p, om=orthpoly5_dlmf:q-Jacobi-p,
  params={n}, args={x}{a}{b}{q},
  description={the little $q$-Jacobi polynomial},% $\littleqJacobipolyp{n}$},
  sortkey={p 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3;#4\mright)]
\defSpecFun{qLaguerrepolyL}[2]{L\ifx.#1.\else^{(#1)}\fi_{#2}}[%
  meaning=q-Laguerre-polynomial-L, om=orthpoly5_dlmf:q-Laguerre_L,
  params={\alpha}{n}, args={x}{q},
  description={the $q$-Laguerre polynomial},% $\qLaguerrepolyL{\alpha}{n}$},
  sortkey={L 2 3 z z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{StieltjesWigertpolyS}[1]{S_{#1}}[%
  meaning=Stieltjes-Wigert-polynomial-S, om=orthpoly5_dlmf:Stieltjes-Wigert_S,
  params={n}, args={x}{q},
  description={the Stieltjes--Wigert polynomial},% $\StieltjesWigertpolyS{n}$},
  sortkey={S 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
% Indexed defn; seemingly not?
\defSpecFun{discqHermitepolyhI}[1]{h_{#1}}[%
  meaning=discrete-q-Hermite-polynomial-h-I, om=orthpoly5_dlmf:q-Hermite_h_I,
  params={n}, args={x}{q},
  description={the discrete $q$-Hermite I polynomial},% $\discqHermitepolyhI{n}$},
  sortkey={h 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{discqHermitepolyhII}[1]{\tilde{h}_{#1}}[%
  meaning=discrete-q-Hermite-polynomial-h-II, om=orthpoly5_dlmf:q-Hermite_h_II,
  params={n}, args={x}{q},
  description={the discrete $q$-Hermite II polynomial},% $\discqHermitepolyhII{n}$},
  sortkey={h 2 3 z - z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{AskeyWilsonpolyp}[1]{p_{#1}}[%
  meaning=Askey-Wilson-polynomial-p, om=orthpoly5_dlmf:Askey-Wilson_p,
  params={n}, args={x}{a}{b}{c}{d}{q},
  description={the Askey--Wilson polynomial},% $\AskeyWilsonpolyp{n}$},
  sortkey={p 6 1 z z z z z z z},
  ]{6}[\mleft(#1;#2,#3,#4,#5\,|\,#6\mright)]
\defSpecFun{AlSalamChiharapolyQ}[1]{Q_{#1}}[%
  meaning=AlSalam-Chihara-polynomial-Q, om=orthpoly5_dlmf:Al-Salam-Chihara_Q,
  params={n}, args={x}{a}{b}{q},
  description={the Al-Salam--Chihara polynomial},% $\AlSalamChiharapolyQ{n}$},
  sortkey={Q 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3\,|\,#4\mright)]
\defSpecFun{contqultrasphpoly}[1]{C_{#1}}[%
  meaning=q-ultraspherical-polynomial, om=orthpoly5_dlmf:cont-q-ultraspherical,
  params={n}, args={x}{\beta}{q},
  description={the continuous $q$-ultraspherical (or Rogers) polynomial},% $\contqultrasphpoly{n}$},
  sortkey={C 3 1 z z z z},
  ]{3}[\mleft(#1;#2\,|\,#3\mright)]
\defSpecFun{contqHermitepolyH}[1]{H_{#1}}[%
  meaning=continuous-q-Hermite-polynomial-H, om=orthpoly5_dlmf:cont-q-Hermite_H,
  params={n}, args={x}{q},
  description={the continuous $q$-Hermite polynomial},% $\contqHermitepolyH{n}$},
  sortkey={H 2 1 z z z},
  ]{2}[\mleft(#1\,|\,#2\mright)]
\defSpecFun{qRacahpolyR}[1]{R_{#1}}[%
  meaning=q-Racah-polynomial-R, om=orthpoly5_dlmf:q-Racah_R,
  params={n}, args={x}{\alpha}{\beta}{\gamma}{\delta}{q},
  description={the $q$-Racah polynomial},% $\qRacahpolyR{n}$},
  sortkey={R 6 1 z z z z z z z},
  ]{6}[\mleft(#1;#2,#3,#4,#5\,|\,#6\mright)]
\defSpecFun{Besselpolyy}[1]{y_{#1}}[%
  meaning=Bessel-polynomial-y, om=orthpoly4_dlmf:Bessel_y,
  params={n}, args={x}{a},
  description={the Bessel polynomial},% $\Besselpolyy{n}$},
  sortkey={y 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{PollaczekpolyP}[2]{P^{(#1)}_{#2}}[%
  meaning=Pollaczek-polynomial-P, om=orthpoly4_dlmf:Pollaczek_P,
  params={\lambda}{n}, args={x}{a}{b},
  description={the Pollaczek polynomial},% $\PollaczekpolyP{\lambda}{n}$},
  sortkey={P 3 3 z z z z z},
  ]{3}[\mleft(#1;#2,#3\mright)]
\defSpecFun{diskpoly}[3]{R^{(#1)}_{#2,#3}}[%
  meaning=disk-orthogonal-polynomial-R, om=orthpoly4_dlmf:disk-polnomial,
  params={\alpha}{m}{n}, args={z},
  description={the disk polynomial},% $\diskpoly{\alpha}{m}{n}$},
  sortkey={R 1 3 zz z z},
  ]{1}[\mleft(#1\mright)]
\defSpecFun{trianglepoly}[5]{P^{#1,#2,#3}_{#4,#5}}[%
  meaning=triangle-orthogonal-polynomial-P, om=orthpoly4_dlmf:triangle-polynomial,
  params={\alpha}{\beta}{\gamma}{m}{n}, args={x}{y},
  description={the triangle polynomial},% $\trianglepoly{\alpha}{\beta}{\gamma}{m}{n}$},
  sortkey={P 2 3 zz zzz z z},
  ]{2}[\mleft(#1,#2\mright)]
\defSpecFun{contqinvHermitepolyh}[1]{h_{#1}}[%
  meaning=continuous-q-inverse-Hermite-polynomial-h, om=orthpoly5_dlmf:cont-qinv-Hermite_h,
  params={n}, args={x}{q},
  description={the continuous $q^{-1}$-Hermite polynomial},% $\contqinvHermitepolyh{n}$},
  sortkey={h 2 1 z z z},
  ]{2}[\mleft(#1\,|\,#2\mright)]
\defSpecFun{assLegendrepoly}[1]{P_{#1}}[%
  meaning=Legendre-spherical-polynomial-P, om=orthpoly4_dlmf:assoc_Legendre_P,
  params={n}, args={x}{c},
  description={the associated Legendre polynomial},% $\assLegendrepoly{n}$},
  sortkey={P 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{assJacobipolyP}[3]{P^{(#1,#2)}_{#3}}[%
  meaning=associated-Jacobi-polynomial-P, om=orthpoly4_dlmf:assoc_Jacobi_P,
  params={\alpha}{\beta}{n}, args={x}{c},
  description={the associated Jacobi polynomial},% $\assJacobipolyP{\alpha}{\beta}{n}$},
  sortkey={P 2 3 z zz z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{qinvAlSalamChiharapolyQ}[1]{Q_{#1}}[%
  meaning=q-inverse-AlSalam-Chihara-polynomial-Q, om=orthpoly5_dlmf:qinv-Al-Salam-Chihara_Q,
  params={n}, args={x}{a}{b}{q^{-1}},
  description={the $q^{-1}$-Al-Salam--Chihara polynomial},% $\qinvAlSalamChiharapolyQ{n}$},
  sortkey={Q 4 1 z z z z z},
  ]{4}[\mleft(#1;#2,#3\,|\,#4\mright)]
\defSpecFun{shiftJacobipolyG}[1]{G_{#1}}[%
  meaning=shifted-Jacobi-polynomial-G, om=orthpoly2_dlmf:Jacobi_G_shifted,
  params={n}, args={p}{q}{x},
  description={the shifted Jacobi polynomial},% $\shiftJacobipolyG{n}$},
  sortkey={G 3 1 z z z z},
  ]{3}
\defSpecFun{dilChebyshevpolyC}[1]{C_{#1}}[%
  meaning=dilated-Chebyshev-polynomial-second-kind-C, om=orthpoly2_dlmf:Chebyshev_C_dilated,
  params={n}, args={x},
  description={the dilated Chebyshev polynomial of first kind},% $\dilChebyshevpolyC{n}$},
  sortkey={C 1 1 z z},
  ]{1}
\defSpecFun{dilChebyshevpolyS}[1]{S_{#1}}[%
  meaning=dilated-Chebyshev-polynomial-first-kind-S, om=orthpoly2_dlmf:Chebyshev_S_dilated,
  params={n}, args={x},
  description={the dilated Chebyshev polynomial of second kind},% $\dilChebyshevpolyS{n}$},
  sortkey={S 1 1 z z},
  ]{1}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 19 Elliptic Integrals
\defSpecFun{incellintFk}{F}[%
  meaning=elliptic-integral-first-kind-F, om=ellint1_dlmf:F,
  args={\phi}{k},
  description={(Legendre's) incomplete elliptic integral of the first kind (of modulus $k$)},% $F(\phi,k)$},
  sortkey={F 2 0 z z},
  ]{2}
\defSpecFun{incellintEk}{E}[%
  meaning=elliptic-integral-second-kind-E, om=ellint1_dlmf:E,
  args={\phi}{k},
  description={(Legendre's) incomplete elliptic integral of the second kind (of modulus $k$)},
%     $\incellintEk@{\phi}{k}$},
  sortkey={E 2 0 z z},
  ]{2}
\defSpecFun{incellintDk}{D}[%
  meaning=elliptic-integral-third-kind-D, om=ellint1_dlmf:D,
  args={\phi}{k},
  description={the incomplete elliptic integral of Janke (of modulus $k$)},
%     $\incellintDk@{\phi}{k}$},
  sortkey={D 2 0 z z},
  ]{2}
\defSpecFun{incellintPik}{\Pi}[%
  meaning=elliptic-integral-third-kind-Pi, om=ellint1_dlmf:Pi,
  args={\phi}{\alpha^2}{k},
  description={(Legendre's) incomplete elliptic integral of the third kind (of modulus $k$)},
%     $\incellintPik@{\phi}{\alpha^2}{k}$},
  sortkey={Pi 3 0 z z z},
  ]{3}
\defSpecFun{compellintKk}{K}[%
  meaning=complete-elliptic-integral-first-kind-K, om=ellint1_dlmf:comp_K,
  args={k},
  description={(Legendre's) complete elliptic integral of the first kind (of modulus $k$)},
%    $\compellintKk@{k}$},
  sortkey={K 1 z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{compellintEk}{E}[%
  meaning=complete-elliptic-integral-second-kind-E, om=ellint1_dlmf:comp_E,
  args={k},
  description={(Legendre's) complete elliptic integral of the second kind (of modulus $k$)},
%     $\compellintEk@{k}$},
  sortkey={E 1 0 z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{compellintDk}{D}[%
  meaning=complete-elliptic-integral-D, om=ellint1_dlmf:comp_D,
  args={k},
  description={the complete elliptic integral of Janke (of modulus $k$)},
%     $\compellintDk@{k}$},
  sortkey={D 1 0 z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{compellintPik}{\Pi}[%
  meaning=complete-elliptic-integral-third-kind-Pi, om=ellint1_dlmf:comp_Pi,
  args={\alpha^2}{k},
  description={(Legendre's) complete elliptic integral of the third kind (of modulus $k$)},
%     $\compellintPik@{\alpha^2}{k}$},
  sortkey={Pi 2 0 z z},
  ]{2}
\defSpecFun{ccompellintKk}{{K'}}[%
  meaning=complementary-complete-elliptic-integral-first-kind-K, om=ellint1_dlmf:compl_comp_K,
  args={k},
  description={(Legendre's) complementary complete elliptic integral
    of the first kind (of modulus $k$)},% $\ccompellintKk@{k}$},
  sortkey={K 1 2 ' z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{ccompellintEk}{{E'}}[%
  meaning=complementary-complete-elliptic-integral-second-kind-E, om=ellint1_dlmf:compl_comp_E,
  args={k},
  description={(Legendre's) complementary complete elliptic integral
  of the second kind (of modulus $k$)},% $\ccompellintEk@{k}$},
  sortkey={E 1 2 ' z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{Bulirschcompellintcel}{\mathrm{cel}}[%
  meaning=Bulirsch-integral-cel, om=ellint2_dlmf:cel,
  args={k_c}{p}{a}{b},
  description={Bulirsch's complete elliptic integral},
%     $\Bulirschcompellintcel$},
  sortkey={cel 4 0 z z z z},
  ]{4}
% Stub, so indexed definitions take effect
\defSpecFun{Bulirschincellintel}[1]{\mathrm{el}#1}[%
  meaning=Bulirsch-integral-el, om=ellint2_dlmf:el,
  params={i},
  description={placekeeper for indexed Bulirsch's incomplete elliptic integrals},
  ]{0}%
\defSpecFun{Bulirschincellintel{1}}{\mathrm{el1}}[%
  meaning=Bulirsch-integral-el-1, om=ellint2_dlmf:el1,
  args={x}{k_c},
  description={Bulirsch's incomplete elliptic integral of the first kind},% $\Bulirschincellintel{1}$},
  sortkey={el1 2 0 z z},
  ]{2}
\defSpecFun{Bulirschincellintel{2}}{\mathrm{el2}}[%
  meaning=Bulirsch-integral-el-2, om=ellint2_dlmf:el2,
  args={x}{k_c}{a}{b},
  description={Bulirsch's incomplete elliptic integral of the second kind},% $\Bulirschincellintel{2}$},
  sortkey={el2 4 0 z z z z},
  ]{4}
\defSpecFun{Bulirschincellintel{3}}{\mathrm{el3}}[%
  meaning=Bulirsch-integral-el-3, om=ellint2_dlmf:el3,
  args={x}{k_c}{p},
  description={Bulirsch's incomplete elliptic integral of the third kind},% $\Bulirschincellintel{3}$},
  sortkey={el3 3 0 z z z},
  ]{3}
\defSpecFun{CarlsonellintRC}{R_C}[%
  meaning=Carlson-integral-RC, om=ellint3_dlmf:RC,
  args={x}{y},
  sortkey={RC 2 0 z z},
  description={Carlson's elliptic integral combining inverse circular and hyperbolic functions},
  %    $\CarlsonellintRC$},
  ]{2}[\mleft(#1,#2\mright)][]
\defSpecFun{CarlsonsymellintRF}{R_F}[%
  meaning=Carlson-integral-RF, om=ellint3_dlmf:RF,
  args={x}{y}{z},
  description={Carlson's symmetric elliptic integral of first kind},% $\CarlsonsymellintRF$},
  sortkey={RF 3 0 z z z},
  ]{3}[\mleft(#1,#2,#3\mright)][]
\defSpecFun{CarlsonsymellintRJ}{R_J}[%
  meaning=Carlson-integral-RJ, om=ellint3_dlmf:RJ,
  args={x}{y}{z}{p},
  description={Carlson's symmetric elliptic integral of third kind},% $\CarlsonsymellintRJ$},
  sortkey={RJ 4 0 z z z z},
  ]{4}[\mleft(#1,#2,#3,#4\mright)][]
\defSpecFun{CarlsonsymellintRG}{R_G}[%
  meaning=Carlson-integral-RG, om=ellint3_dlmf:RG,
  args={x}{y}{z},
  description={Carlson's symmetric elliptic integral of second kind},% $EllIntRG$},
  sortkey={RG 3 0 z z z},
  ]{3}[\mleft(#1,#2,#3\mright)][]
\defSpecFun{CarlsonsymellintRD}{R_D}[%
  meaning=Carlson-integral-RD, om=ellint3_dlmf:RD,
  args={x}{y}{z},
  description={Carlson's elliptic integral symmetric in only two variables},% $\CarlsonsymellintRD$},
  sortkey={RD 3 0 z z z},
  ]{3}[\mleft(#1,#2,#3\mright)][]
\defSpecFun{Carlsonmultivarhyper}[1]{R_{#1}}[%
  meaning=Carlson-integral-R, om=ellint3_dlmf:R_multivariate,
  params={-a}, args={b_1,\dots,b_n}{z_1,\dots,z_n},
  description={Carlson's multivariate hypergeometric function},% $\Carlsonmultivarhyper{-a}$},
  sortkey={R 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
% This is never actually used in any sensible way!
\defSpecFun{LauricellaFD}{F_D}[%
  meaning=Lauricella-FD, om=hypergeon2:lauricella_FD,
  args={x}{y}{z}{p},
  description={Lauricella's (multivariate) hypergeometric function},% $\LauricellaFD$},
  sortkey={FD 4 0 z z z z},
  ]{4}[\mleft(#1;#2;#3;#4\mright)]
\defSpecFun{AGM}{M}[%
  meaning=arithmetic-geometric-mean, % role=OPFUNCTION, om=?_dlmf,
  args={a}{g},
  description={arithmetic-geometric mean},
  sortkey={M 2 0 z z},
  ]{2}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 20 Theta Functions
\defSpecFun{Jacobithetaq}[1]{\theta_{#1}}[%
  meaning=Jacobi-theta, om=thetafun1_dlmf:theta,
  params={j}, args={z}{q},
  description={the Jacobi theta function of $q$},% $\Jacobithetaq{j}@{z}{q}$},
  sortkey={theta 2 1 z z z},
  ]{2}
\defSpecFun{Jacobithetatau}[1]{\theta_{#1}}[%
  meaning=Jacobi-theta-tau, om=thetafun2_dlmf:theta,
  params={j}, args={z}{\tau},
  description={the Jacobi theta function of $\tau$},% $\Jacobithetatau(j)@{z}{\tau}$},
  sortkey={theta 2 1 z z z},
  ]{2}[\mleft(#1\middle|#2\mright)]
\defSpecFun{Jacobithetacombinedq}[2]{\varphi_{#1,#2}}[%
  meaning=Jacobi-theta-combined, om=thetafun1_dlmf:phi,
  params={n}{m}, args={z}{q},
  description={the combined theta function},% $\Jacobithetacombinedq{n}{m}$},
  sortkey={phi 2 1 zz z z},
  ]{2}[\mleft(#1,#2\mright)]
% (could be a version as function of $\tau$ ?)
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 21 Multidimensional Theta Functions
\defSpecFun{Riemanntheta}{\theta}[%
  meaning=Riemann-theta, om=thetafun3_dlmf:theta,
  args={z}{\Omega},
  description={the Riemann theta function},% $\Riemanntheta$},
  sortkey={theta 2 0 z z},
  ]{2}[\mleft(#1 \middle| #2\mright)]
\defSpecFun{scRiemanntheta}{\hat{\theta}}[%
  meaning=Riemann-theta-hat, om=thetafun3_dlmf:scaled_theta,
  args={z}{\Omega},
  description={the scaled Riemann theta function (or oscillatory part of the theta function)},
%     $\scRiemanntheta$},
  sortkey={theta 2 3 - z z},
  ]{2}[\mleft(#1 \middle| #2\mright)]
\defSpecFun{Riemannthetachar}[2]{\theta\genfrac{[}{]}{0pt}{}{#1}{#2}}[%
  meaning=Riemann-theta-characterstics, om=thetafun3_dlmf:theta_char,
  params={\alpha}{\beta}, args={z}{\Omega},
  description={the Riemann theta function with characteristics},
%     $\Riemannthetachar{\alpha}{\beta}$},
  sortkey={theta 2 0 zz zz},
  ]{2}[\mleft(#1 \middle| #2\mright)]
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 22 Jacobian Elliptic Functions
\defSpecFun{Jacobiellsnk}{\operatorname{sn}}[%
   meaning=Jacobi-elliptic-sn,role=OPFUNCTION, om=ellfunk1_dlmf:sn,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellsnk$ (of modulus $k$)},
   sortkey={sn 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellnsk}{\operatorname{ns}}[%
   meaning=Jacobi-elliptic-ns,role=OPFUNCTION, om=ellfunk1_dlmf:ns,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellnsk$ (of modulus $k$)},
   sortkey={ns 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellcnk}{\operatorname{cn}}[%
   meaning=Jacobi-elliptic-cn,role=OPFUNCTION, om=ellfunk1_dlmf:cn,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellcnk$ (of modulus $k$)},
   sortkey={cn 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellnck}{\operatorname{nc}}[%
   meaning=Jacobi-elliptic-nc,role=OPFUNCTION, om=ellfunk1_dlmf:nc,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellnck$ (of modulus $k$)},
   sortkey={nc 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobielldnk}{\operatorname{dn}}[%
   meaning=Jacobi-elliptic-dn,role=OPFUNCTION, om=ellfunk1_dlmf:dn,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobielldnk$ (of modulus $k$)},
   sortkey={dn 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellndk}{\operatorname{nd}}[%
   meaning=Jacobi-elliptic-nd,role=OPFUNCTION, om=ellfunk1_dlmf:nd,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellndk$ (of modulus $k$)},
   sortkey={nd 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellsdk}{\operatorname{sd}}[%
   meaning=Jacobi-elliptic-sd,role=OPFUNCTION, om=ellfunk1_dlmf:sd,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellsdk$ (of modulus $k$)},
   sortkey={sd 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobielldsk}{\operatorname{ds}}[%
   meaning=Jacobi-elliptic-ds,role=OPFUNCTION, om=ellfunk1_dlmf:ds,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobielldsk$ (of modulus $k$)},
   sortkey={ds 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellcdk}{\operatorname{cd}}[%
   meaning=Jacobi-elliptic-cd,role=OPFUNCTION, om=ellfunk1_dlmf:cd,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellcdk$ (of modulus $k$)},
   sortkey={cd 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobielldck}{\operatorname{dc}}[%
   meaning=Jacobi-elliptic-dc,role=OPFUNCTION, om=ellfunk1_dlmf:dc,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobielldck$ (of modulus $k$)},
   sortkey={dc 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellsck}{\operatorname{sc}}[%
   meaning=Jacobi-elliptic-sc,role=OPFUNCTION, om=ellfunk1_dlmf:sc,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellsck$ (of modulus $k$)},
   sortkey={sc 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiellcsk}{\operatorname{cs}}[%
   meaning=Jacobi-elliptic-cs,role=OPFUNCTION, om=ellfunk1_dlmf:cs,
   args={u}{k},
   description={the Jacobian elliptic function $\Jacobiellcsk$ (of modulus $k$)},
   sortkey={cs 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
%%% \defSpecFun{AbstractJacobiPQ}[1]{#1}[%
\defSpecFun{genJacobiellk}[2]{\operatorname{#1\InvisibleComma#2}}[%
   meaning=abstract-Jacobi-elliptic,role=OPFUNCTION, om=ellfunk1_dlmf:pq,
%%%   params={pq}, args={u}{k},
   params={p}{q}, args={u}{k},
   description={the generic Jacobian elliptic function $\genJacobiellk{p}{q}$ (of modulus $k$)},
   sortkey={pq 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{aJacobiellsnk}{\operatorname{arcsn}}[%
   meaning=inverse-Jacobi-elliptic-sn, om=ellfunk1_dlmf:arcsn,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellsnk$ (of modulus $k$)},% $\aJacobiellsnk@{x}{k}$},
   sortkey={arcsn 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellcnk}{\operatorname{arccn}}[%
   meaning=inverse-Jacobi-elliptic-cn, om=ellfunk1_dlmf:arccn,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellcnk$ (of modulus $k$)},% $\aJacobiellcnk@{x}{k}$},
   sortkey={arccn 2 0 z z},
   ]{2}
\defSpecFun{aJacobielldnk}{\operatorname{arcdn}}[%
   meaning=inverse-Jacobi-elliptic-dn, om=ellfunk1_dlmf:arcdn,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobielldnk$ (of modulus $k$)},% $\aJacobielldnk@{x}{k}$},
   sortkey={arcdn 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellsdk}{\operatorname{arcsd}}[%
   meaning=inverse-Jacobi-elliptic-sd, om=ellfunk1_dlmf:arcsd,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobielldsk$ (of modulus $k$)},% $\aJacobiellsdk@{x}{k}$},
   sortkey={arcsd 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellcdk}{\operatorname{arccd}}[%
   meaning=inverse-Jacobi-elliptic-cd, om=ellfunk1_dlmf:arccd,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellcdk$ (of modulus $k$)},% $\aJacobiellcdk@{x}{k}$},
   sortkey={arccd 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellsck}{\operatorname{arcsc}}[%
   meaning=inverse-Jacobi-elliptic-sc, om=ellfunk1_dlmf:arcsc,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellsck$ (of modulus $k$)},% $\aJacobiellsck@{x}{k}$},
   sortkey={arcsc 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellnsk}{\operatorname{arcns}}[%
   meaning=inverse-Jacobi-elliptic-ns, om=ellfunk1_dlmf:arcns,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellnsk$ (of modulus $k$)},% $\aJacobiellnsk@{x}{k}$},
   sortkey={arcns 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellnck}{\operatorname{arcnc}}[%
   meaning=inverse-Jacobi-elliptic-nc, om=ellfunk1_dlmf:arcnc,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellnck$ (of modulus $k$)},% $\aJacobiellnck@{x}{k}$},
   sortkey={arcnc 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellndk}{\operatorname{arcnd}}[%
   meaning=inverse-Jacobi-elliptic-nd, om=ellfunk1_dlmf:arcnd,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellndk$ (of modulus $k$)},% $\aJacobiellndk@{x}{k}$},
   sortkey={arcnd 2 0 z z},
   ]{2}
\defSpecFun{aJacobielldsk}{\operatorname{arcds}}[%
   meaning=inverse-Jacobi-elliptic-ds, om=ellfunk1_dlmf:arcds,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobielldsk$ (of modulus $k$)},% $\aJacobielldsk@{x}{k}$},
   sortkey={arcds 2 0 z z},
   ]{2}
\defSpecFun{aJacobielldck}{\operatorname{arcdc}}[%
   meaning=inverse-Jacobi-elliptic-dc, om=ellfunk1_dlmf:arcdc,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobielldck$ (of modulus $k$)},% $\aJacobielldck@{x}{k}$},
   sortkey={arcdc 2 0 z z},
   ]{2}
\defSpecFun{aJacobiellcsk}{\operatorname{arccs}}[%
   meaning=inverse-Jacobi-elliptic-cs, om=ellfunk1_dlmf:arccs,
   args={x}{k},
   description={the inverse of the Jacobian elliptic function $\Jacobiellcsk$ (of modulus $k$)},% $\aJacobiellcsk@{x}{k}$},
   sortkey={arccs 2 0 z z},
   ]{2}
%%%%\defSpecFun{arcAbstractJacobiPQ}[1]{#1}[%
\defSpecFun{agenJacobiellk}[2]{\operatorname{arc#1\InvisibleComma#2}}[%
   meaning=inverse-abstract-Jacobi-elliptic, om=ellfunk1_dlmf:arcpq,
%%%   params={pq}, args={x}{k},
   params={p}{q}, args={x}{k},
   description={the inverse of the generic Jacobian elliptic function $\genJacobiellk{p}{q}$
       (of modulus $k$)},% $\agenJacobiellk{p}{q}@{x}{k}$},
   sortkey={arcpq 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{Jacobiamk}{\operatorname{am}}[%
   meaning=Jacobi-elliptic-amplitude,role=OPFUNCTION, om=ellfunk1_dlmf:am,
   args={x}{k},
   description={the Jacobi's amplitude function (of modulus $k$)},% $\Jacobiamk@{x}{k}$},
   sortkey={am 2 0 z z},
   ]{2}[\mleft(#1,#2\mright)][#1]
\defSpecFun{JacobiEpsilonk}{\mathcal{E}}[%
   meaning=Jacobi-Epsilon, om=ellfunk1_dlmf:Epsilon,
   args={x}{k},
   description={Jacobi's Epsilon function (of modulus $k$)},% $\JacobiEpsilonk@{x}{k}$},
   sortkey={E 2 0 z z},
   ]{2}
\defSpecFun{JacobiZetak}{\mathrm{Z}}[%
   meaning=Jacobi-Zeta, om=ellfunk1_dlmf:Zeta,
   args={x}{k},
   description={Jacobi's Zeta function (of modulus $k$)},% $\JacobiZetak@{x}{k}$},
   sortkey={Z 2 0 z z},
   ]{2}[\mleft(#1|#2\mright)]
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 23 Weierstrass Elliptic and Modular Functions
\defSpecFun{Weierstrasselatt}[1]{e_{#1}}[%
   meaning=Weierstrass-e-on-lattice, om=weier2_dlmf:e,
   args={L},
   description={the Weierstrass lattice roots (on Lattice)},
   sortkey={e 2 0 z z},
   ]{1}[\mleft(#1\mright)][]
\defSpecFun{Weierstrassinvarlatt}[1]{g_{#1}}[%
   meaning=Weierstrass-invariants-on-lattice, om=weier2_dlmf:g,
   args={L},
   description={the Weierstrass invariants (on Lattice)},
   sortkey={g 2 0 z z},
   ]{1}[\mleft(#1\mright)][]
\defSpecFun{Weierstrassplatt}{\wp}[%
   meaning=Weierstrass-P-on-lattice, om=weier2_dlmf:p,
   args={z}{L},
   description={the Weierstrass $\Weierstrassplatt$-function (on Lattice)},
   sortkey={p 2 0 z z},
   ]{2}[\mleft(#1|#2\mright)][\mleft(#1\mright)]
\defSpecFun{Weierstrasszetalatt}{\zeta}[%
  meaning=Weierstrass-zeta-on-lattice, om=weier2_dlmf:zeta,
  args={z}{L},
  description={the Weierstrass zeta function $\Weierstrasszetalatt$ (on Lattice)},
  sortkey={zeta 2 0 z z},
  ]{2}[\mleft(#1|#2\mright)][\mleft(#1\mright)]
\defSpecFun{Weierstrasssigmalatt}{\sigma}[%
  meaning=Weierstrass-sigma-on-lattice, om=weier2_dlmf:sigma,
  args={z}{L},
  description={the Weierstrass sigma function $\Weierstrasssigmalatt$ (on Lattice)},
  sortkey={sigma 2 0 z z},
  ]{2}[\mleft(#1|#2\mright)][\mleft(#1\mright)]
\defSpecFun{Weierstrasspinvar}{\wp}[%
  meaning=Weierstrass-P-on-invariants, om=weier3_dlmf:p,
  args={z}{g_2}{g_3},
  description={the Weierstrass $\Weierstrasspinvar$-function (on invariants)},
  sortkey={p 3 0 z z z},
  ]{3}[\mleft(#1;#2,#3\mright)][\mleft(#1\mright)]
\defSpecFun{Weierstrasszetainvar}{\zeta}[%
  meaning=Weierstrass-zeta-on-invariants, om=weier3_dlmf:zeta,
  args={z}{g_2}{g_3},
  description={the Weierstrass zeta function $\Weierstrasszetainvar$ (on invariants)},
  sortkey={zeta 3 0 z z z},
  ]{3}[\mleft(#1;#2,#3\mright)][\mleft(#1\mright)]
\defSpecFun{Weierstrasssigmainvar}{\sigma}[%
  meaning=Weierstrass-sigma-on-invariants, om=weier3_dlmf:sigma,
  args={z}{g_2}{g_3},
  description={the Weierstrass sigma function $\Weierstrasssigmainvar$ (on invariants)},
  sortkey={sigma 3 0 z z z},
  ]{3}[\mleft(#1;#2,#3\mright)][\mleft(#1\mright)]
\defSpecFun{modularlambdatau}{\lambda}[%
  meaning=modular-Lambda, om=weier1_dlmf:lambda,
  args={\tau},
  description={the elliptic modular function},% $\lambda$},
  sortkey={lambda 1 0 z},
  ]{1}
% (could be a version as function of $q ?)
\defSpecFun{KleincompinvarJtau}{J}[%
  meaning=Kleins-invariant-modular-J, om=weier1_dlmf:J,
  args={\tau},
  description={Klein's complete invariant},% $\KleincompinvarJtau$},
  sortkey={J 1 0 z},
  ]{1}
% (could be a version as function of $q ?)  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 24 Bernoulli and Euler Polynomials
\defSpecFun{BernoullinumberB}[1]{B_{#1}}[
  meaning=Bernoulli-number-B, om=DLMF_BP:BernoullinumberB,
  params={n},
  signature={\nonnegIntegers\mapsto\Rationals},
  description={the Bernoulli number},% $\BernoullinumberB{n}$},
  sortkey={B 1 z},
  ]{0}
\defSpecFun{EulernumberE}[1]{E_{#1}}[%
  meaning=Euler-number-E, om=DLMF_BP:EulernumberE,
  params={n},
  signature={\nonnegIntegers\mapsto\Integers},
  description={the Euler number},% $\EulernumberE{n}$},
  sortkey={E 1 z},
  ]{0}
\defSpecFun{BernoullipolyB}[1]{B_{#1}}[
  meaning=Bernoulli-polynomial-B, om=DLMF_BP:BernoullipolyB,
  params={n}, args={x},
  signature={\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the Bernoulli polynomial},% $\BernoullipolyB{n}@{x}$},
  sortkey={B 1 1 z z},
  ]{1}
\defSpecFun{EulerpolyE}[1]{E_{#1}}[%
  meaning=Euler-polynomial-E, om=DLMF_BP:EulerpolyE,
  params={n}, args={x},
  signature={\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the Euler polynomial},% $\EulerpolyE{n}@{x}$},
  sortkey={E 1 1 z z},
  ]{1}
% Are these 2 "functions" or "polynomials" ?????
\defSpecFun{perBernoulliB}[1]{\widetilde{B}_{#1}}[%
  meaning=periodic-Bernoulli-polynomial-B, om=DLMF_BP_per:perBernoulliB,
  params={n}, args={x},
  signature={\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the periodic Bernoulli function},% $\perBernoulliB{n}$},
  sortkey={B 1 3 z - z},
  ]{1}
\defSpecFun{perEulerE}[1]{\widetilde{E}_{#1}}[%
  meaning=periodic-Euler-polynomial-E, om=DLMF_BP_per:perEulerE,
  params={n}, args={x},
  signature={\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the periodic Euler function},% $\perEulerE{n}$},
  sortkey={E 1 3 z - z},
  ]{1}
\defSpecFun{genBernoullipolyB}[2]{B^{(#1)}_{#2}}[%
  meaning=generalized-Bernoulli-polynomial-B, om=DLMF_BP_gen:genBernoullipolyB,
  params={\ell}{n}, args={x},
  signature={\Integers\times\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the generalized Bernoulli polynomial},% $\genBernoullipolyB{\ell}{n}$},
  sortkey={B 1 3 z z z},
  ]{1}
\defSpecFun{genEulerpolyE}[2]{E^{(#1)}_{#2}}[%
  meaning=generalized-Euler-polynomial-E, om=DLMF_BP_gen:genEulerpolyE,
  params={\ell}{n}, args={x},
  signature={\Integers\times\nonnegIntegers\times\Reals\mapsto\Reals},
  description={the generalized Euler polynomial},% $\genEulerpolyE{\ell}{n}$},
  sortkey={E 1 3 z z z},
  ]{1}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 25 Zeta and Related Functions
\defSpecFun{Riemannzeta}{\zeta}[%
  meaning=Riemann-zeta, om=zeta1_dlmf:zeta,
  args={s},
  description={the Riemann zeta function},% $\Riemannzeta$},
  sortkey={zeta 1 0 z},
  ]{1}
\defSpecFun{Riemannxi}{\xi}[%
  meaning=Riemann-xi, om=zeta1_dlmf:xi,
  args={s},
  description={the Riemann $\Riemannxi$ function},% $\Riemannxi$},
  sortkey={xi 1 0 z},
  ]{1}
\defSpecFun{Hurwitzzeta}{\zeta}[%
  meaning=Hurwitz-zeta, om=zeta1_dlmf:Hurwitz,
  args={s}{a},
  description={the Hurwitz zeta function},% $\Hurwitzzeta$},
  sortkey={zeta 2 0 z z},
  ]{2}
\defSpecFun{dilog}{\mathrm{Li}_2}[%
  meaning=dilogarithm, om=zeta1_dlmf:dilog,
  args={z},
  description={the dilogarithm},% $\dilog$},
  sortkey={Li 1 0 z},
  ]{1}
\defSpecFun{polylog}[1]{\mathrm{Li}_{#1}}[%
  meaning=polylogarithm, om=zeta1_dlmf:polylog,
  params={s}, args={z},
  description={the polylogarithm},% $\polylog{s}$},
  sortkey={Li 1 1 z z},
  ]{1}
\defSpecFun{Jonquierephi}{\phi}[%
  meaning=Jonquiere-phi, om=zeta1_dlmf:phi,
  args={z}{s},
  description={Truesdell's notation for polylogarithm},% $\Jonquierephi$},
  sortkey={phi 2 0 z z},
  ]{2}
\defSpecFun{perZeta}{F}[%
  meaning=periodic-zeta, om=zeta1_dlmf:zeta_periodic,
  args={x}{s},
  description={the periodic zeta function},% $\perZeta$},
  sortkey={F 2 0 z z},
  ]{2}
\defSpecFun{LerchPhi}{\Phi}[%
  meaning=Lerch-Phi, om=zeta1_dlmf:Lerch_Phi,
  args={z}{s}{a},
  description={Lerch's transcendent},% $\LerchPhi$},
  sortkey={Phi 3 0 z z z},
  ]{3}
\defSpecFun{DirichletL}{L}[%
  meaning=Dirichlet-L, om=zeta1_dlmf:Dirichlet_L,
  args={s}{\chi},
  description={the Dirichlet $\DirichletL$-function},
  sortkey={L 2 0 z z},
  ]{2}
\defSpecFun{ChebyshevPsi}{\psi}[%
  meaning=Chebyshev-psi, om=zeta1_dlmf:psi,
  args={x},
  description={the Chebyshev $\ChebyshevPsi$-function},
  sortkey={psi 1 0 z},
  ]{1}
\defSpecFun{EulersumH}{H}[%
  meaning=Euler-sum-H, om=zeta1_dlmf:Euler_sum,
  args={s},
  description={the Euler sum},% $\EulersumH$},
  sortkey={H 1 0 z},
  ]{1}
\defSpecFun{genEulersumH}{H}[%
  meaning=generalized-Euler-sum-H, om=zeta1_dlmf:gen_Euler_sum,
  args={s}{z},
  description={the generalized Euler sum},% $\genEulersumH$},  
  sortkey={H 2 0 z z},
  ]{2}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 26 Combinatorial Analysis
\defSpecFun{card}[1]{\mleft|#1\mright|}[
  meaning=cardinality, om=set1:size,
  params={x},
  description={the cardinality of a set},% $\card{x}$},
  sortkey={*m| 1 0 z},
]{0}
\defSpecFun{npartitions}[1][]{\if.#1.p\else p_{#1}\fi}[
  meaning=partition-function-at-most, om=combinat3_dlmf:partitions_parts,
  params={m}, args={n},
  description={the total number of partitions of $n$ into at most $m$ parts},% $\npartitions[m]@{n}$},
  sortkey={p 1 1 z z},
  ]{1}
\defSpecFun{npartitions[]}{p}[
  meaning=partition-function, om=combinat3_dlmf:partitions,
  args={n},
  description={the total number of partitions of $n$},% $\npartitions@{n}$},
  sortkey={p 1 1 z z},
  ]{1}
\defSpecFun{Catalannumber}{C}[%
  meaning=Catalan-number, om=combinat2_dlmf:Catalan,
  args={n},
  description={the Catalan number},% $\Catalannumber$},
  sortkey={C 1 0 z},
  ]{1}
\defSpecFun{Bellnumber}{B}[%
  meaning=Bell-number, om=combinat1:Bell,
  args={n},
  description={the Bell number},% $\Bellnumber$},
  sortkey={B 1 0 z},
  ]{1}
\defSpecFun{Stirlingnumbers}{s}[%
  meaning=Stirling-number-first-kind-S, om=combinat1:Stirling_s,
  args={n}{k},
  description={the Stirling number of the first kind},% $\Stirlingnumbers$},
  sortkey={s 2 0 z z},
  ]{2}
\defSpecFun{StirlingnumberS}{S}[%
  meaning=Stirling-number-second-kind-S, om=combinat1:Stirling_S,
  args={n}{k},
  description={the Stirling number of the second kind},% $\StirlingnumberS$},
  sortkey={S 2 0 z z},
  ]{2}
\defSpecFun{nrestpartitions}[1][]{\if.#1.p\else p_{#1}\fi}[%
  meaning=restricted-partitions-P-at-most, om=combinat3_dlmf:restricted_partitions_parts,
  params={m}, args={\mathrm{condition}}{n},
  description={the restricted number of partitions of $n$ into at most $m$ parts},
%     $\nrestpartitions[m]$},
  sortkey={p 2 1 z z z},
  ]{2}
\defSpecFun{nrestpartitions[]}{p}[%
  meaning=restricted-partitions-P, om=combinat3_dlmf:restricted_partitions,
  args={\mathrm{condition}}{n},
  description={the restricted number of partitions of $n$},% $\nrestpartitions$},
  sortkey={p 2 1 z z z},
  ]{2}
\defSpecFun{ncompositions}[1][]{\if.#1.c\else c_{#1}\fi}[%
  meaning=number-of-compositions-C-into-parts, om=combinat3_dlmf:compositions_parts,
  params={m}, args={n},
  description={the number of compositions of $n$ into exactly $m$ parts},% $\ncompositions[m]$},
  sortkey={c 1 1 z z},
  ]{1}
\defSpecFun{ncompositions[]}{c}[%
  meaning=number-of-compositions-C, om=combinat3_dlmf:compositions,
  args={n},
  description={the number of compositions of $n$},% $\ncompositions$},
  sortkey={c 1 1 z z},
  ]{1}
% NOTE: This is never used with the optional argument!
%%% \defSpecFun{nrestcompositions}[1][]{\if.#1.c\else c_{#1}\fi}[%
\defSpecFun{nrestcompositions}{c}[%
  meaning=restricted-number-of-compositions-C-into-parts, om=combinat3_dlmf:restricted_compositions_parts,
  args={\mathrm{condition}}{n},
  description={the restricted number of compositions of $n$ into exactly $m$ parts},
%     $\nrestcompositions[m]$},
%  sortkey={c 2 1 z z z},
  sortkey={c 2 0 z z},
  ]{2}
% \defSpecFun{nrestcompositions[]}{c}[%
%   meaning=restricted-number-of-compositions-C, om=combinat3_dlmf:restricted_compositions,
%   args={\mathrm{condition}}{n},
%   description={the restricted number of compositions of $n$},% $\nrestcompositions$},
%   sortkey={c 2 1 z z z},
%   ]{2}
\defSpecFun{nplanepartitions}{\mathrm{pp}}[%
  meaning=plane-partitions-PP, om=combinat3_dlmf:plane_partitions,
  args={n},
  description={the number of plane partitions of $n$},% $\nplanepartitions$},
  sortkey={pp 1 0 z},
  ]{1}
\defSpecFun{npermutations}[1]{\mathfrak{S}_{#1}}[%
  meaning=set-of-permutations, om=combinat3_dlmf:p,
  params={n},
  description={the number of permutations of $n$},% $\npermutations{n}$},
  sortkey={S 0 1 z},
  ]{0}
\defSpecFun{Euleriannumber}[2]{\genfrac{<}{>}{0pt}{}{#1}{#2}}[%
  meaning=Eulerian-number, om=combinat2_dlmf:Eulerian,
  params={n}{k},
  description={the Eulerian number},% $\Euleriannumber{n}{k}$},
  sortkey={*r<< 2 0 z z},
  ]{0}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 27 Functions of Number Theory
\defSpecFun{Dedekindeta}{\eta}[%
  meaning=Dedekind-modular-Eta, om=numtheory2_dlmf:Dedikind_eta,
  args={\tau},
  description={Dedekind's eta function (or modular function)},% $\Dedekindeta$},
  sortkey={eta 1 0 z},
  ]{1}
\defSpecFun{nprimesdiv}{\nu}[%
  meaning=number-of-primes-dividing-nu, om=numtheory1_dlmf:nprimes_dividing,
  args={n},
  description={the number of distinct primes dividing $n$},% $\nprimesdiv@{n}$},
  sortkey={nu 1 0 z},
  ]{1}
\defSpecFun{nprimes}{\pi}[%
  meaning=number-of-primes-less-pi, om=numtheory1_dlmf:nprimes,
  args={x},
  description={the number of primes not exceeding $x$},% $\nprimes@{x}$},
  sortkey={pi 1 0 z},
  ]{1}
\defSpecFun{Eulertotientphi}[1][]{\phi_{#1}}[%
  meaning=Euler-totient-phi-n, om=numtheory1_dlmf:powers_prime,
  params={k}, args={n},
  description={the sum of $k$\textsuperscript{th} powers of integers relatively prime to $n$},
%     $\Eulertotientphi[k]$},
  sortkey={phi 1 1 z z},
  ]{1}
\defSpecFun{Eulertotientphi[]}{\phi}[%
  meaning=Euler-totient-phi, om=numtheory1_dlmf:totient,
  args={n},
  description={Euler's totient, the number of positive integers relatively prime to $n$,
     ($\Eulertotientphi=\Eulertotientphi[0]$)},
  sortkey={phi 1 0 z},
  ]{1}
\defSpecFun{ndivisors}[1][]{d_{#1}}[%
  meaning=divisor-function-D, om=numtheory1_dlmf:ndivisors_factors,
  params={k}, args={n},
  description={the number of ways of expressing $n$ as product of $k$ factors},
%     $\ndivisors[k]$},
  sortkey={d 1 1 z z},
  ]{1}
\defSpecFun{ndivisors[]}{d}[%
  meaning=divisor-function-D, om=numtheory1_dlmf:ndivisors,
  args={n},
  description={the number of divisors of $n$ (divisor function)},
%     $\ndivisors=\ndivisors[2]$},
  sortkey={d 1 0 z},
  ]{1}
\defSpecFun{sumdivisors}[1]{\sigma_{#1}}[%
  meaning=divisor-sigma, om=numtheory1_dlmf:sum_divisors,
  params={\alpha}, args={n},
  description={the sum of powers of divisors of $n$},% $\sumdivisors{\alpha}$},
  sortkey={sigma 1 1 z z},
  ]{1}
\defSpecFun{JordanJ}[1]{J_{#1}}[%
  meaning=Jordan-J, om=numtheory1_dlmf:Jordan_J,
  params={k}, args={n},
  description={Jordan's function},% $\JordanJ{k}$},
  sortkey={J 1 1 z z},
  ]{1}
\defSpecFun{Moebiusmu}{\mu}[%
  meaning=Moebius-mu, om=numtheory1_dlmf:Moebius_mu,
  args={n},
  description={the M\"obius function},% $\Moebiusmu$},
  sortkey={mu 1 0 z},
  ]{1}
\defSpecFun{Liouvillelambda}{\lambda}[%
  meaning=Liouville-lambda, om=numtheory1_dlmf:Liouville_lambda,
  args={n},
  description={the Liouville's function},% $\Liouvillelambda$},
  sortkey={lambda 1 0 z},
  ]{1}
\defSpecFun{MangoldtLambda}{\Lambda}[%
  meaning=Mangoldt-Lambda, om=numtheory1_dlmf:Mangoldt_lambda,
  args={n},
  description={Mangoldt's function},% $\MangoldtLambda$},
  sortkey={Lambgda 1 0 z},
  ]{1}
\defSpecFun{Legendresym}[2]{(#1|#2)}[%
  meaning=Legendre-symbol, om=numtheory2_dlmf:Legendre_symbol,
  params={n}{p},
  description={the Legendre symbol},% $\Legendresym{n}{p}$},
  sortkey={*p( 2 0 z z},
  ]{0}
\defSpecFun{Jacobisym}[2]{(#1|#2)}[%
  meaning=Jacobi-symbol, om=numtheory2_dlmf:Jacobi_symbol,
  params={n}{p},
  description={the Jacobi symbol},% $\Jacobisym{n}{p}$},
  sortkey={*p( 2 0 z z},
  ]{0}
\defSpecFun{Ramanujansum}[1]{c_{#1}}[%
  meaning=Ramanujan-sum, om=numtheory2_dlmf:Rmanujan_sum,
  params={k}, args={n},
  description={Ramanujan's sum},% $\Ramanujansum{k}$},
  sortkey={c 1 1 z z},
  ]{1}
\defSpecFun{Gausssum}{G}[%
  meaning=Gauss-sum, om=numtheory2_dlmf:Gauss_sum,
  args={n}{\Dirichletchar},
  description={the Gauss sum},% $\Gausssum$},
  sortkey={G 2 0 z z},
  ]{2}
\defSpecFun{Waringg}{g}[%
  meaning=Waring-g, om=numtheory2_dlmf:Waring_g,
  args={k},
  description={Waring's function $\Waringg$},
  sortkey={g 1 0 z},
  ]{1}
\defSpecFun{WaringG}{G}[%
  meaning=Waring-G, om=numtheory2_dlmf:Waring_G,
  args={k},
  description={Waring's function $\WaringG$},
  sortkey={G 1 0 z},
  ]{1}
\defSpecFun{nsquares}[1]{r_{#1}}[%
  meaning=number-of-squares-R, om=numtheory2_dlmf:nsquares,
  params={k}, args={n},
  description={the number of squares},% $\nsquares{k}$},
  sortkey={r 1 1 z z},
  ]{1}
\defSpecFun{EulerPhi}{\mathit{f}}[%
  meaning=Euler-phi, om=numtheory2_dlmf:Euler_phi,
  args={x},
  description={Euler's reciprocal function},% $\EulerPhi$},
  sortkey={f 1 0 z},
  ]{1}
\defSpecFun{DiscriminantDelta}{\Delta}[%
  meaning=discriminant-delta, om=numtheory2_dlmf:discriminant,
  args={\tau},
  description={the discriminant function},% $\DiscriminantDelta$},
  sortkey={Delta 1 0 z},
  ]{1}
\defSpecFun{Ramanujantau}{\tau}[%
  meaning=Ramanujan-tau, om=numtheory2_dlmf:Ramanujan_tau,
  args={n},
  description={Ramanujan's tau function},% $\Ramanujantau$},
  sortkey={tau 1 0 z},
  ]{1}
%% Not sure this is a function, but a KIND of function????
\defSpecFun{Dirichletchar}[1][]{\if.#1.\chi\else\chi_{#1}\fi}[
  meaning=Dirichlet-character, om=numtheory2_dlmf:Dirichlet_character,
  params={r}, args={n}{k},
  description={the Dirichlet character},% $\Dirichletchar{r}$},
  sortkey={chi 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 28 Mathieu Functions and Hill’s Equation
\defSpecFun{Mathieueigvala}[1]{a_{#1}}[%
  meaning=Mathieu-eigenvalue-a, om=mathieu1_dlmf:eiga,
  params={n}, args={q},
  description={the eigenvalues of the Mathieu's equation $\Mathieueigvala{n}$},
  sortkey={a 1 1 z z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{Mathieueigvalb}[1]{b_{#1}}[%
  meaning=Mathieu-eigenvalue-b, om=mathieu1_dlmf:eigb,
  params={n}, args={q},
  description={the eigenvalues of the Mathieu's equation $\Mathieueigvalb{n}$},
  sortkey={b 1 1 z z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{Mathieuce}[1]{\mathrm{ce}_{#1}}[%
  meaning=Mathieu-ce, om=mathieu1_dlmf:ce,
  params={n}, args={z}{q},
  description={the Mathieu function $\Mathieuce{n}$},
  sortkey={ce 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{Mathieuse}[1]{\mathrm{se}_{#1}}[%
  meaning=Mathieu-se, om=mathieu1_dlmf:se,
  params={n}, args={z}{q},
  description={the Mathieu function $\Mathieuse{n}$},
  sortkey={se 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{Mathieufe}[1]{\mathrm{fe}_{#1}}[%
  meaning=Mathieu-fe, om=mathieu1_dlmf:fe,
  params={n}, args={z}{q},
  description={the second solution of Mathieu's equation $\Mathieufe{n}$},
  sortkey={fe 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{Mathieuge}[1]{\mathrm{ge}_{#1}}[%
  meaning=Mathieu-ge, om=mathieu1_dlmf:ge,
  params={n}, args={z}{q},
  description={the second solution of Mathieu's equation $\Mathieuge{n}$},
  sortkey={ge 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{Mathieueigvallambda}[1]{\lambda_{#1}}[%
  meaning=Mathieu-eigenvalue-lambda, om=mathieu1_dlmf:eiglambda,
  params={\nu+2n}, args={q},
  description={the eigenvalues of Mathieu's equation $\Mathieueigvallambda{\nu+2n}$},
  sortkey={lambda 1 1 z z},
  ]{1}[\mleft(#1\mright)][]
\defSpecFun{Mathieume}[1]{\mathrm{me}_{#1}}[%
  meaning=Mathieu-me, om=mathieu1_dlmf:me,
  params={n}, args={z}{q},
  description={the Mathieu function $\Mathieume{n}$},
  sortkey={me 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuCe}[1]{\mathrm{Ce}_{#1}}[%
  meaning=modified-Mathieu-Ce, om=mathieu2_dlmf:Ce,
  params={\nu}, args={z}{q},
  description={the modified Mathieu function $\modMathieuCe{\nu}$},
  sortkey={Ce 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuSe}[1]{\mathrm{Se}_{#1}}[%
  meaning=modified-Mathieu-Se, om=mathieu2_dlmf:Se,
  params={\nu}, args={z}{q},
  description={the modified Mathieu function $\modMathieuSe{\nu}$},
  sortkey={Se 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuMe}[1]{\mathrm{Me}_{#1}}[%
  meaning=modified-Mathieu-Me, om=mathieu2_dlmf:Me,
  params={\nu}, args={z}{q},
  description={the modified Mathieu function $\modMathieuMe{\nu}$},
  sortkey={Me 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuFe}[1]{\mathrm{Fe}_{#1}}[%
  meaning=modified-Mathieu-Fe, om=mathieu2_dlmf:Fe,
  params={\nu}, args={z}{q},
  description={the modified Mathieu function $\modMathieuFe{\nu}$},
  sortkey={Fe 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuGe}[1]{\mathrm{Ge}_{#1}}[%
  meaning=modified-Mathieu-Ge, om=mathieu2_dlmf:Ge,
  params={\nu}, args={z}{q},
  description={the modified Mathieu function $\modMathieuGe{\nu}$},
  sortkey={Ge 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuM}[2]{{\mathrm{M}^{(#1)}_{#2}}}[%
  meaning=modified-Mathieu-M, om=mathieu2_dlmf:M,
  params={j}{\nu}, args={z}{h},
  description={the modified Mathieu function $\modMathieuM{j}{\nu}$},
  sortkey={M 2 3 z z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{radMathieuMc}[2]{{\mathrm{Mc}^{(#1)}_{#2}}}[%
  meaning=modified-Mathieu-Mc, om=mathieu3_dlmf:Mc,
  params={j}{n}, args={z}{h},
  description={the radial Mathieu function $\radMathieuMc{j}{n}$},
  sortkey={Mc 2 3 z z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{radMathieuMs}[2]{{\mathrm{Ms}^{(#1)}_{#2}}}[%
  meaning=modified-Mathieu-Ms, om=mathieu3_dlmf:Ms,
  params={j}{n}, args={z}{h},
  description={the radial Mathieu function $\radMathieuMs{j}{n}$},
  sortkey={Ms 2 3 z z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuIe}[1]{\mathrm{Ie}_{#1}}[%
  meaning=modified-Mathieu-Ie, om=mathieu2_dlmf:Ie,
  params={n}, args={z}{h},
  description={the modified Mathieu function $\modMathieuIe{n}$},
  sortkey={Ie 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuIo}[1]{\mathrm{Io}_{#1}}[%
  meaning=modified-Mathieu-Io, om=mathieu2_dlmf:Io,
  params={n}, args={z}{h},
  description={the modified Mathieu function $\modMathieuIo{n}$},
  sortkey={Io 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuKe}[1]{\mathrm{Ke}_{#1}}[%
  meaning=modified-Mathieu-Ke, om=mathieu2_dlmf:Ke,
  params={n}, args={z}{h},
  description={the modified Mathieu function $\modMathieuKe{n}$},
  sortkey={Ke 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
\defSpecFun{modMathieuKo}[1]{\mathrm{Ko}_{#1}}[%
  meaning=modified-Mathieu-Ko, om=mathieu2_dlmf:Ko,
  params={n}, args={z}{h},
  description={the modified Mathieu function $\modMathieuKo{n}$},
  sortkey={Ko 2 1 z z z},
  ]{2}[\mleft(#1,#2\mright)][\mleft(#1\mright)]
% % Are Fc, Gc, Fs, Gs really noteworthy?  NO!
% \defSpecFun{MathieuFc}[1]{\mathrm{Fc}_{#1}}[%
%   meaning=Mathieu-Fc, om=mathieu4_dlmf:Fc,
%   params={m}, args={z}{h},
%   description={the Mathieu function},% $\MathieuFc{m}$},
%   ]{2}
% \defSpecFun{MathieuGc}[1]{\mathrm{Gc}_{#1}}[%
%   meaning=Mathieu-Gc, om=mathieu4_dlmf:Gc,
%   params={m}, args={z}{h},
%   description={the Mathieu function},% $\MathieuGc{m}$},
%   ]{2}
% \defSpecFun{MathieuFs}[1]{\mathrm{Fs}_{#1}}[%
%   meaning=Mathieu-Fs, om=mathieu4_dlmf:Fs,
%   params={m}, args={z}{h},
%   description={the Mathieu function},% $\MathieuFs{m}$},
%   ]{2}
% \defSpecFun{MathieuGs}[1]{\mathrm{Gs}_{#1}}[%
%   meaning=Mathieu-Gs, om=mathieu4_dlmf:Gs,
%   params={m}, args={z}{h},
%   description={the Mathieu function},% $\MathieuGs{m}$},
%   ]{2}
\defSpecFun{modMathieuD}[1]{\mathrm{D}_{#1}}[%
  meaning=Mathieu-D, om=mathieu4_dlmf:D,
  params={j}, args={\nu}{\mu}{z},
  description={the cross-products of modified Mathieu functions and their derivatives},
%     $\modMathieuD{j}$},
  sortkey={D 3 1 z z z z},
  ]{3}
\defSpecFun{radMathieuDs}[1]{\mathrm{Ds}_{#1}}[%
  meaning=Mathieu-Ds, om=mathieu4_dlmf:Ds,
  params={j}, args={n}{m}{z},
  description={the cross-products of radial Mathieu functions and their derivatives
     $\radMathieuDs{j}$
},
  sortkey={Ds 3 1 z z z z},
  ]{3}
\defSpecFun{radMathieuDc}[1]{\mathrm{Dc}_{#1}}[%
  meaning=Mathieu-Dc, om=mathieu4_dlmf:Dc,
  params={j}, args={n}{m}{z},
  description={the cross-products of radial Mathieu functions and their derivatives
     $\radMathieuDc{j}$},
  sortkey={Dc 3 1 z z z z},
  ]{3}
\defSpecFun{radMathieuDsc}[1]{\mathrm{Dsc}_{#1}}[%
  meaning=Mathieu-Dsc, om=mathieu4_dlmf:Dsc,
  params={j}, args={n}{m}{z},
  description={the cross-products of radial Mathieu functions and their derivatives
     $\radMathieuDsc{j}$},
  sortkey={Dsc 3 1 z z z z},
  ]{3}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 29 Lamé Functions
\defSpecFun{Lameeigvala}[2]{a^{#1}_{#2}}[%
  meaning=Lame-eigenvalue-a, om=lame1_dlmf:a,
  params={n}{\nu}, args={k^2},
  description={the eigenvalues of Lam\'e's equation $\Lameeigvala{n}{\nu}$},
  sortkey={a 1 3 z z z},
  ]{1}
\defSpecFun{Lameeigvalb}[2]{b^{#1}_{#2}}[%
  meaning=Lame-eigenvalue-b, om=lame1_dlmf:b,
  params={n}{\nu}, args={k^2},
  description={the eigenvalues of Lam\'e's equation $\Lameeigvalb{n}{\nu}$},
  sortkey={b 1 3 z z z},
  ]{1}
\defSpecFun{LameEc}[2]{\mathit{Ec}^{#1}_{#2}}[%
  meaning=Lame-Ec, om=lame1_dlmf:Ec,
  params={m}{\nu}, args={z}{k^2},
  description={the Lam\'e function $\LameEc{m}{\nu}$},
  sortkey={Ec 2 3 z z z z},
  ]{2}
\defSpecFun{LameEs}[2]{\mathit{Es}^{#1}_{#2}}[%
  meaning=Lame-Es, om=lame1_dlmf:Es,
  params={m}{\nu}, args={z}{k^2},
  description={the Lam\'e function $\LameEs{m}{\nu}$},
  sortkey={Es 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolyuE}[2]{\mathit{uE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-uE, om=lame1_dlmf:uE,
  params={m}{2n}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolyuE{m}{2n}$},
  sortkey={uE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolysE}[2]{\mathit{sE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-sE, om=lame1_dlmf:sE,
  params={m}{2n+1}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolysE{m}{2n+1}$},
  sortkey={sE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolycE}[2]{\mathit{cE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-cE, om=lame1_dlmf:cE,
  params={m}{2n+1}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolycE{m}{2n+1}$},
  sortkey={cE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolydE}[2]{\mathit{dE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-dE, om=lame1_dlmf:dE,
  params={m}{2n+1}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolydE{m}{2n+1}$},
  sortkey={dE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolyscE}[2]{\mathit{scE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-scE, om=lame1_dlmf:scE,
  params={m}{2n+2}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolyscE{m}{2n+2}$},
  sortkey={scE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolysdE}[2]{\mathit{sdE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-sdE, om=lame1_dlmf:sdE,
  params={m}{2n+2}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolysdE{m}{2n+2}$},
  sortkey={sdE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolycdE}[2]{\mathit{cdE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-cdE, om=lame1_dlmf:cdE,
  params={m}{2n+2}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolycdE{m}{2n+2}$},
  sortkey={cdE 2 3 z z z z},
  ]{2}
\defSpecFun{LamepolyscdE}[2]{\mathit{scdE}^{#1}_{#2}}[%
  meaning=Lame-polynomial-scdE, om=lame1_dlmf:scdE,
  params={m}{2n+3}, args={z}{k^2},
  description={the Lam\'e polynomial $\LamepolyscdE{m}{2n+3}$},
  sortkey={scdE 2 3 z z z z},
  ]{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 30 Spheroidal Wave Functions
\defSpecFun{sphwavePsreal}[2]{\mathsf{Ps}^{#1}_{#2}}[%
  meaning=spheroidal-wave-on-cut-Ps, om=sphwave2_dlmf:Ps_real,
  params={m}{n}, args={x}{\gamma^2},
  description={the spheroidal wave function of first kind},% $\sphwavePsreal{m}{n}$},
  sortkey={Ps 2 3 z z z z},
  ]{2}
\defSpecFun{spheigvalLambda}[2]{\lambda^{#1}_{#2}}[%
  meaning=spheroidal-eigenvalue-lambda, om=sphwave1_dlmf:eig,
  params={m}{n}, args={\gamma^2},
  description={the eigenvalues of the spheroidal differential equation},
%     $\spheigvalLambda{m}{n}$},
  sortkey={lambda 1 3 z z z},
  ]{1}
\defSpecFun{sphwaveQsreal}[2]{\mathsf{Qs}^{#1}_{#2}}[%
  meaning=spheroidal-wave-on-cut-Qs, om=sphwave2_dlmf:Qs_real,
  params={m}{n}, args={x}{\gamma^2},
  description={the spheroidal wave function of second kind},% $\sphwaveQsreal{m}{n}$},
  sortkey={Qs 2 3 z z z z},
  ]{2}
\defSpecFun{sphwavePs}[2]{\mathit{Ps}^{#1}_{#2}}[%
  meaning=spheroidal-wave-Ps, om=sphwave1_dlmf:Ps,
  params={m}{n}, args={z}{\gamma^2},
  description={the spheroidal wave function of complex argument},% $\sphwavePs{m}{n}$},
  sortkey={Ps 2 3 z z z z},
  ]{2}
\defSpecFun{sphwaveQs}[2]{\mathit{Qs}^{#1}_{#2}}[%
  meaning=spheroidal-wave-Qs, om=sphwave1_dlmf:Qs,
  params={m}{n}, args={z}{\gamma^2},
  description={the spheroidal wave function of complex argument},% $\sphwaveQs{m}{n}$},
  sortkey={Qs 2 3 z z z z},
  ]{2}
\defSpecFun{radsphwaveS}[3]{S^{#1(#2)}_{#3}}[%
  meaning=radial-spheroidal-wave-S, om=sphwave1_dlmf:S,
  params={m}{j}{n}, args={z}{\gamma},
  description={the radial spheroidal wave function},% $\radsphwaveS{m}{j}{n}$},
  sortkey={S 2 3 z zz z z},
  ]{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 31 Heun Functions
\defSpecFun{HeunHl}{\mathit{H\!\ell}}[%
  meaning=Heun-local, om=heun1_dlmf:Hl,
  args={a}{q}{\alpha}{\beta}{\gamma}{\delta}{z},
  description={the (fundamental) Heun function},% $\HeunHl$},
  sortkey={Hl 7 0 z z z z z z z},
  ]{7}[\mleft(#1,#2;#3,#4,#5,#6;#7\mright)][\mleft(#7\mright)]
%% NOTE: What the \nu means needs clarification!
\defSpecFun{HeunHf}[4][]{(#3,#4)\mathit{Hf}_{#2}\ifx.#1.\else^{#1}\fi}[%
  meaning=Heun-function, om=heun1_dlmf:Hf,
  params={\nu}{m}{s_1}{s_2}, args={a}{q_m}{\alpha}{\beta}{\gamma}{\delta}{z},
  description={the Heun function},% $\HeunHf{\nu}{m}{s_1}{s_2}$},
  sortkey={Hf 7 3 z z z z z z z z z},
  ]{7}[\mleft(#1,#2;#3,#4,#5,#6;#7\mright)][\mleft(#7\mright)]
\defSpecFun{HeunpolyHp}[2]{\mathit{Hp}_{#1,#2}}[%
  meaning=Heun-polynomial-m, om=heun1_dlmf:Hp,
  params={n}{m}, args={a}{q_{n,m}}{-n}{\beta}{\gamma}{\delta}{z},
  description={the Heun polynomial},% $\HeunpolyHp{n}{m}$},
  sortkey={Hp 7 1 zz z z z z z z z},
  ]{7}[\mleft(#1,#2;#3,#4,#5,#6;#7\mright)][\mleft(#7\mright)]
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 32 Painlevé Transcendents
% ???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 33 Coulomb Functions
\defSpecFun{regCoulombF}[1]{F_{#1}}[%
  meaning=regular-Coulomb-F, om=coulomb1_dlmf:F,
  params={\ell},args={\eta}{\rho},
  description={the regular Coulomb (radial) function (for repulsive interactions)
   $\regCoulombF{\ell}$},
  sortkey={F 2 1 z z z},
  ]{2}
\defSpecFun{normCoulombC}[1]{C_{#1}}[%
  meaning=Coulomb-C, om=coulomb2_dlmf:C,
  params={\ell},args={\eta},
  description={the normalizing constant for Coulomb (radial) function},% $\normCoulombC{\ell}$},
  sortkey={C 1 1 z z},
  ]{1}
\defSpecFun{irregCoulombH}[2]{{H^{#1}_{#2}}}[%
  meaning=irregular-Coulomb-H, om=coulomb1_dlmf:H,
  params={\pm}{\ell},args={\eta}{\rho},
  description={the irregular Coulomb (radial) function (for repulsive interactions)
      $\irregCoulombH{\pm}{\ell}$},
  sortkey={H 2 3 z z z z},
  ]{2}
\defSpecFun{Coulombphasetheta}[1]{{\theta_{#1}}}[%
  meaning=Coulomb-phase, om=coulomb2_dlmf:theta,
  params={\ell},args={\eta}{\rho},
  description={the phase of the irregular Coulomb function $\irregCoulombH{\pm}{\ell}$},
%     $\Coulombphasetheta{\ell}$},
  sortkey={theta 2 1 z z z},
  ]{2}
\defSpecFun{Coulombphasesigma}[1]{{\sigma_{#1}}}[%
  meaning=Coulomb-phase-shift, om=coulomb2_dlmf:sigma,
  params={\ell},args={\eta},
  description={the phase shift of the irregular Coulomb function $\irregCoulombH{\pm}{\ell}$},
%    $\Coulombphasesigma{\ell}$},
  sortkey={sigma 1 1 z z},
  ]{1}
\defSpecFun{irregCoulombG}[1]{G_{#1}}[%
  meaning=irregular-Coulomb-G, om=coulomb1_dlmf:G,
  params={\ell},args={\eta}{\rho},
  description={the irregular Coulomb (radial) function (for repulsive interactions)
    $\irregCoulombG{\ell}$},
  sortkey={G 2 1 z z z},
  ]{2}
\defSpecFun{envCoulumbM}[1]{M_{#1}}[%
  meaning=envelope-Coulomb-M, om=coulomb2_dlmf:env_M,
  params={\ell},args={\eta}{\rho},
  description={the envelope of the Coulomb functions (for repulsive interactions)},
  sortkey={M 2 1 z z z},
  ]{2}
\defSpecFun{regCoulombf}{f}[%
  meaning=Coulomb-f, om=coulomb1_dlmf:f,
  args={\epsilon}{\ell}{r},
  description={the regular Coulomb (radial) function (for attractive interactions)
    $\regCoulombf$},
  sortkey={f 3 0 z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{irregCoulombh}{h}[%
  meaning=Coulomb-h, om=coulomb1_dlmf:h,
  args={\epsilon}{\ell}{r},
  description={the irregular Coulomb (radial) function (for attractive interactions) $\irregCoulombh$},
  sortkey={h 3 0 z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{regCoulombs}{s}[%
  meaning=Coulomb-s, om=coulomb1_dlmf:s,
  args={\epsilon}{\ell}{r},
  description={the regular Coulomb (radial) function (for attractive interactions) $\regCoulombs$},
  sortkey={s 3 0 z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{irregCoulombc}{c}[%
  meaning=Coulomb-c, om=coulomb1_dlmf:c,
  args={\epsilon}{\ell}{r},
  description={the irregular Coulomb (radial) function (for attractive interactions) $\irregCoulombc$},
  sortkey={c 3 0 z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{Coulombturnr}{r_{\mathrm{tp}}}[%
  meaning=Coulomb-outer-turning-point, om=coulomb2_dlmf:r,
  args={\epsilon}{\ell},
  description={the outer turning point for Coulomb (radial) functions (for repulsive interactions)},
%     $\Coulombturnr$},
  sortkey={r 2 1 tp z z},
  ]{2}
\defSpecFun{Coulombturnrho}{\rho_{\mathrm{tp}}}[%
  meaning=Coulomb-radial-outer-turning-point, om=coulomb2_dlmf:rho,
  args={\eta}{\ell},
  description={the outer turning point for Coulomb (radial) functions (for attractive interactions)},
%     $\Coulombturnrho$},
  sortkey={rho 2 1 tp z z},
  ]{2}
  
%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% % Definitions from 34 3j, 6j, 9j Symbols
%%% % Eventually fixup so we get "3j" w/o args! \Wignerthreejsym, \Wignersixjsym, \Wignerninejsym
%%% \defSpecFun{Threej}[6]{{\begin{pmatrix}#1&#2&#3\\#4&#5&#6\end{pmatrix}}}[
%%%   meaning=threej, om=wigner1_dlmf:threej,
%%%   description={Wigner 3$j$ symbol},
%%%   params={j_1}{j_2}{j_3}{m_1}{m_2}{m_3},
%%%   ]{0}
%%% \defSpecFun{Sixj}[6]{{\begin{Bmatrix}#1&#2&#3\\#4&#5&#6\end{Bmatrix}}}[
%%%   meaning=sixj, om=wigner1_dlmf:sixj,
%%%   description={Wigner 6$j$ symbol},
%%%   params={j_1}{j_2}{j_3}{l_1}{l_2}{l_3},
%%%   ]{0}
%%% \defSpecFun{Ninej}[9]{{\begin{Bmatrix}#1&#2&#3\\#4&#5&#6\\#7&#8&#9\end{Bmatrix}}}[
%%%   meaning=ninej, om=wigner1_dlmf:ninej,
%%%   description={Wigner 9$j$ symbol},
%%%   params={j_{11}}{j_{12}}{j_{13}}{j_{21}}{j_{22}}{j_{23}}{j_{31}}{j_{32}}{j_{33}},
%%%   ]{0}
%%% This is not so much a "notation" as one of the expressions which equals a Clebsch-Gordan coef.
%%% This needs to be included since it appears in notations
%%% but I've marked it as "obsolete" to keep it out of official lists... 
\defSpecFun{ClebschGordan}[6]{\mleft(#1\;#2\;#3\;#4 | #1\; #3\; #5\,\,#6\mright)}[
  meaning=clebsch-gordan, om=wigner1_dlmf:Clebsch-Gordan,
  description={the Clebsch-Gordan coefficients},
  OBSOLETE=1,
  params={j_1}{m_1}{j_2}{m_2}{j_3}{m_3},
  sortkey={*p( 6 0 z z z z z z},
  ]{0}
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 35 Functions of Matrix Argument
\defSpecFun{exptrace}{\mathrm{etr}}[%
  meaning=exponential-trace, role=LIMITOP, % om=?_dlmf,
  args={\mathbf{X}},
  description={the exponential of the trace},% $\exptrace@{\mathbf{X}}$},  
  sortkey={etr 1 0 z},
  ]{1}
\defSpecFun{multivarEulerGamma}[1]{\Gamma_{#1}}[%
  meaning=multivariate-Euler-Gamma, om=hypergeo5_dlmf?:gamma,
  params={m}, args={a},
  description={the multivariate gamma function},% $\multivarEulerGamma{m}$},
  sortkey={Gamma 1 1 z z},
  ]{1}
\defSpecFun{multivarEulerBeta}[1]{\mathrm{B}_{#1}}[%
  meaning=multivariate-Euler-Beta, om=hypergeo5_dlmf?:Beta,
  params={m}, args={a}{b},
  description={multivariate beta function},% $\multivarEulerBeta{m}$},
  sortkey={B 2 1 z z z},
  ]{2}
\defSpecFun{zonalpolyZ}[1]{Z_{#1}}[%
  meaning=zonal-polynomial, % role=OPFUNCTION, om=?_dlmf,
  params={\kappa}, args={\mathbf{T}},
  description={the zonal polynomial},% $\zonalpolyZ{\kappa}$},
  sortkey={Z 1 1 z z},
  ]{1}
\defSpecFun{BesselAmat}[1]{A_{#1}}[%
  meaning=Bessel-of-matrix-A, om=bessel6_dlmf?:A,
  params={\nu}, args={\mathbf{T}},
  description={the Bessel function of matrix argument (first kind)},% $\BesselAmat{\nu}$},
  sortkey={A 1 1 z z},
  ]{1}
\defSpecFun{BesselBmat}[1]{B_{#1}}[%
  meaning=Bessel-of-matrix-B, om=bessel6_dlmf?:B,
  params={\nu}, args={\mathbf{T}},
  description={the Bessel function of matrix argument (second kind)},% $\BesselBmat{\nu}$},
  sortkey={B 1 1 z z},
  ]{1}
\defSpecFun{genhyperPsimat}{\Psi}[%
  meaning=confluent-hypergeometric-of-matrix-Psi, om=hypergeo5_dlmf?:Psi,
  args={a}{b}{\mathbf{T}},
  description={the confluent hypergeometric function of matrix argument (second kind)},
%     $\genhyperPsimat$},
  sortkey={Psi 3 0 z z z},
  ]{3}[\mleft(#1;#2;#3\mright)]
\defSpecFun{genhyperFmat}[2]{{{}_{#1}F_{#2}}}[%
  meaning=Gauss-hypergeometric-of-matrix-pFq, om=hypergeo5_dlmf?:pFq,
  params={p}{q}, args={a_1,\dots,a_p}{b_1,\dots,b_q}{z},
  description={the generalized hypergeometric function of matrix argument},% $\genhyperF{p}{q}$},
  sortkey={F 3 1 zz z z z},
  ]{3}[\mleft(#1;#2;#3\mright)][\mleft({#1 \atop #2};#3\mright)][\mleft(#3\mright)]
\defSpecFun{JacobifunPmat}[3]{P^{(#1,#2)}_{#3}}[%
  meaning=Jacobi-function-of-matrix-P, om=orthpoly2_dlmf:Jacobi_Pmat,
  params={\gamma}{\delta}{\nu}, args={x},
  description={the Jacobi function of matrix argument},% $\JacobifunPmat{\gamma}{\delta}{\nu}$},
  sortkey={P 1 3 z zz z},
  ]{1}
\defSpecFun{LaguerrefunLmat}[2][]{L\ifx.#1.\else^{(#1)}\fi_{#2}}[%
  meaning=Laguerre-function-of-matrix-L, om=orthpoly2_dlmf:Laguerre_L,
  params={\gamma}{\nu}, args={x},
  description={the Laguerre function of matrix argument},% $\LaguerrefunL[\gamma]{\nu}$},
  sortkey={L 1 3 z z z},
  ]{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions from 36 Integrals with Coalescing Saddles
\defSpecFun{cuspcatastrophe}[1]{\Phi_{#1}}[%
  meaning=cuspoid-catastrophe, om=canonint1_dlmf,
  params={K}, args={t}{x},
  description={the cuspoid catastrophe of codimension $K$},% $\cuspcatastrophe{K}$},
  sortkey={Phi 2 1 z z z},
  ]{2}[\mleft(#1;#2\mright)]
\defSpecFun{ellumbcatastrophe}{\Phi^{(\mathrm{E})}}[%
  meaning=elliptic-umbilic-catastrophe, om=canonint1_dlmf,
  args={s}{t}{x},
  description={the elliptic umbilic catastrophe},% $\ellumbcatastrophe$},
  sortkey={Phi 3 2 E z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{hyperumbcatastrophe}{\Phi^{(\mathrm{H})}}[%
  meaning=hyperbolic-umbilic-catastrophe, om=canonint1_dlmf,
  args={s}{t}{x},
  description={the hyperbolic umbilic catastrophe},% $\hyperumbcatastrophe$},
  sortkey={Phi 3 2 H z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{umbcatastrophe}{\Phi^{(\mathrm{U})}}[%
  meaning=umbilic-catastrophe, om=canonint1_dlmf,
  args={s}{t}{x},
  description={the umbilic catastrophe},% $\umbcatastrophe$},
  sortkey={Phi 3 2 U z z z},
  ]{3}[\mleft(#1,#2;#3\mright)]
\defSpecFun{canonint}[1]{\Psi_{#1}}[%
  meaning=canonical-integral, om=canonint1_dlmf,
  params={K}, args={x},
  description={the canonical integral function},% $\canonint{K}$},
  sortkey={Psi 1 1 z z},
  ]{1}
\defSpecFun{umbcanonint}{\Psi^{(\mathrm{U})}}[%
  meaning=umbilic-canonical-integral, om=canonint1_dlmf,
  args={x},
  description={the umbilic canonical integral function},% $\umbcanonint$},
  sortkey={Psi 1 2 U z},
  ]{1}
\defSpecFun{ellumbcanonint}{\Psi^{(\mathrm{E})}}[%
  meaning=elliptic-umbilic-canonical-integral, om=canonint1_dlmf,
  args={x},
  description={the elliptic umbilic canonical integral function},% $\ellumbcanonint$},
  sortkey={Psi 1 2 E z},
  ]{1}
\defSpecFun{hyperumbcanonint}{\Psi^{(\mathrm{H})}}[%
  meaning=hyperbolic-umbilic-canonical-integral, om=canonint1_dlmf,
  args={x},
  description={the hyperbolic umbilic canonical integral function},% $\hyperumbcanonint$},
  sortkey={Psi 1 2 H z},
  ]{1}
\defSpecFun{diffrcanonint}[1]{\Psi_{#1}}[%
  meaning=diffraction-catastrophe, om=canonint1_dlmf,   % WRONG!!!! ==> canonical integral 
  params={K}, args={x}{k},
  description={the diffraction canonical integral},% $\diffrcanonint{K}$},
  sortkey={Psi 2 1 z z z},
  ]{2}[(#1;#2)]
\defSpecFun{umbdiffrcanonint}{\Psi^{(\mathrm{U})}}[%
  meaning=diffraction-umbilic-catastrophe, om=canonint1_dlmf,% WRONG!!!! ==> canonical integral 
  args={x}{k},
  description={the umbilic diffraction canonical integral function},% $\umbdiffrcanonint$},
  sortkey={Psi 2 2 U z z},
  ]{2}[(#1;#2)]
\defSpecFun{ellumbdiffrcanonint}{\Psi^{(\mathrm{E})}}[%
  meaning=diffraction-elliptic-umbilic-catastrophe,role=OPFUNCTION, om=canonint1_dlmf,% WRONG!!!! ==> canonical integral 
  args={x}{k},
  description={the elliptic umbilic diffraction canonical integral function},% $\ellumbdiffrcanonint$},
  sortkey={Psi 2 2 E z z},
  ]{2}[(#1;#2)]
\defSpecFun{hyperumbdiffrcanonint}{\Psi^{(\mathrm{H})}}[%
  meaning=diffraction-hyperbolic-umbilic-catastrophe,role=OPFUNCTION, om=canonint1_dlmf,% WRONG!!!! ==> canonical integral 
  args={x}{k},
  description={the hyperbolic umbilic diffraction canonical integral function},% $\hyperumbdiffrcanonint$},
  sortkey={Psi 2 2 H z z},
  ]{2}[(#1;#2)]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Not-Yet-Defined stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Constants
\defSpecFun{iunit}{\mathrm{i}}[
  meaning=imaginary-unit, role=ID, om=nums1:i,
  description={the imaginary unit},% $\iunit$},
  sortkey={i 0 0},
  ]{0}
\defSpecFun{expe}{\mathrm{e}}[
  meaning=exponential-e, role=ID, om=nums1:e,
  description={the exponential base},% $\expe$},
  sortkey={e 0 0},
  ]{0}
\defSpecFun{cpi}{\pi}[
  meaning=circular-pi, role=ID, om=nums1:pi,
  description={the ratio of the circumference of a circle to its diameter},% $\cpi$},
  sortkey={pi 0 0},
  ]{0}
\defSpecFun{EulerConstant}{\gamma}[
  meaning=Euler-constant, role=ID, om=nums1:gamma,
  description={the Euler constant},% $\EulerConstant$},
  sortkey={gamma 0 0},
  ]{0}
\defSpecFun{StieltjesConstants}[1]{\gamma_{#1}}[
  meaning=Stieltjes-constants, role=ID, om=nums1:gamma,
  description={the Stieltjes constants},% $\StieltjesConstants$},
  sortkey={gamma 0 0},
  ]{0}
\defSpecFun{BoltzmannConstant}{k}[
  meaning=Boltzmann-constant, role=ID, om=physical_consts1:Boltzmann_constant,
  description={the Boltzmann constant},% $\BoltzmannConstant$},
  sortkey={k 0 0},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?k},
  ]{0}
\defSpecFun{Rydbergconst}{R_\infty}[
  meaning=Rydberg-constant, role=ID, % om=?_dlmf,
  description={the Rydberg constant},% $\Rydbergconst$},
  sortkey={R 0 1 infty},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?ryd},
  ]{0}
\defSpecFun{lightspeed}{c}[
  meaning=speed-of-light, role=ID, om=physical_consts1:speed_of_light,
  description={the speed of light},% $\lightspeed$},
  sortkey={c 0 0},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?c},
  ]{0}
\defSpecFun{finestructureconst}{\alpha}[
  meaning=fine-structure-constant, role=ID, % om=?_dlmf,
  description={the fine-structure constant},% $\finestructureconst$},
  sortkey={alpha 0 0},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?alph},
  ]{0}
\defSpecFun{electricconst}{\varepsilon_0}[
  meaning=electric-constant, role=ID, % om=?_dlmf,
  description={the electric constant or vacuum permitivity},% $\electricconst$},
  sortkey={epsilon 0 1 0},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?ep0},
  ]{0}
\defSpecFun{Bohrradius}{a_0}[
  meaning=Bohr-radius, role=ID, % om=?_dlmf,
  description={the Bohr radius},% $\Bohrradius$},
  sortkey={a 0 1 0},
  url={http://physics.nist.gov/cgi-bin/cuu/Value?bohrrada0},
  ]{0}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Combinatorics
% Never used.... maybe never needed?
%\defSpecFun{GaussianProb}{Z}[meaning=Gaussian-probability]{1} om=?_dlmf,
%\defSpecFun{BivariateProb}{g}[meaning=bivariate-probability]{3} om=?_dlmf,
%\defSpecFun{FVariance}{P}[meaning=F-variance]{3}[\mleft(#1|#2,#3\mright)] om=?_dlmf,
%\defSpecFun{tDistribution}{A}[meaning=t-distribution]{2}[\mleft(#1|#2\mright)] om=?_dlmf,
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These were defined (with an unconventional notation, to avoid confusion w/ matrix notation!)
% and used in a section of MultiDimensional Theta functions on Methods of Computation.
% That section has now been commented out (replaced by a reference)
% so it seems perverse to preserve these definitions!
% \defSpecFun{roundedintpart}[1]{\mleft\{#1\mright\}}[%
%   meaning=rounded-integer-part, % om=?_dlmf,
%   params={x},
%   description={the rounded integer part of $x$},% $\roundedintpart@{x}$},
% sortkey={*q\{ 1 0 z}
%   ]{0}
% \defSpecFun{roundedfracpart}[1]{\mleft\{\mleft\{#1\mright\}\mright\}}[%
%   meaning=rounded-fractional-part, % om=?_dlmf,
%   params={x},
%   description={the rounded fractional part of $x$},% $\roundedfracpart@{x}$},
%   sortkey={*q\{\{ 1 0 z},
%   ]{0}

\defSpecFun{pgcd}[1]{\mleft(#1\mright)}[
  meaning=gcd, % om=?,
  params={a_1,\ldots,a_n},
  description={the greatest common divisor},% $pgcd{a_1,\ldots,a_n}$},
  sortkey={*p( 2 0},
  ]{0}
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FUNCTIONS TO BE OBSOLETE!!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NOTE: RECODE the chapter, this isn't important.
\defSpecFun{scterminant}[1]{G_{#1}}[%
  meaning=rescaled-terminant-function, om=expint3_dlmf:scaled_terminant, OBSOLETE=1,
  params={p}, args={z},
  description={the rescaled terminant function},% $\scterminant{p}$},
  sortkey={G 1 1 z z},
  ]{1}
% This is used in NT in a short section.
% Either we should replace explicitly with \Jacobithetaq, or use local defn.
\defSpecFun{AThetaFunction}{\vartheta}[%
  meaning=a-theta-function, OBSOLETE=1,
  args={x},
  description={Alternative notation for $\Jacobithetaq{3}@{0}{x}$},
  ]{1}
