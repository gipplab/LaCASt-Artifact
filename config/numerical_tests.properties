# This file was auto-generated by 'numeric-evaluator.sh'. Update it if you want to use 'lacast-eval-numeric.sh'

# This file serves as the base for 'numerical_tests.properties'. Automatic evaluation scripts may take this
# base, copy it to 'numerical_tests.properties' and add additional properties.

# Specify the subset of test cases. The first number is inclusive, the second number exclusive.
# This setting is overwritten if you set "symbolic_results_data", too. In this case, the symbolically failed
# cases are evaluated regardless of the subset_tests limits you define here.
#subset_tests=1,650

# Set the path to the DLMF dataset.
dlmf_dataset=./dlmf/dlmf-formulae.txt

# Set the path to the results of the symbolic evaluation. This overwrites "subset_tests".
# If this variable is set, only the test cases that finishes with "Failure"
# will be numerically evaluated (all others are skipped skipped).
#symbolic_results_data=/dlmf/results-original/MapleSymbolic/01-AL-symbolic.txt

# Set the path for the output file. This will create (and overwrite existing) file.
#output=./dlmf/results-generated/MapleNumeric/01-AL-numeric.txt

# Enables or disables the DLMF link for each line in the output file. Use "true" or "false".
show_dlmf_links=true

# Define the numerical values you want to test in a list in semantic LaTeX.
# The following values are the one presented in the paper in Figure 3 consisting of
# 4 values on the unit circle, 2 real valued negative and positive values, one negative and positive integer
numerical_values=[\\exp@{\\cpi\\iunit/6}, \\exp@{2\\cpi\\iunit/3}, \\exp@{-\\cpi\\iunit/3}, \\exp@{-5\\cpi\\iunit/6}, -3/2, 3/2, -1/2, 1/2, -2, 2]

# Define special variables (in LaTeX) you want to treat differently from others occurring in
# the test expression. By default we choose: n, m, k, \\ell, l, i, j, \\epsilon, \\varepsilon
special_variables={n, m, k, \\ell, l, i, j, \\epsilon, \\varepsilon}

# The following list defines the values for the variables defined under "special_variables".
special_variables_values=[1, 2, 3]

# Define general set of assumptions (or constraints) that are automatically applied to every test case.
# The default is presented in Figure 3 in our Paper and sets: 
# x,y,a,b,c,r,s,t,\alpha,\beta \in \Real
# x,\alpha,\beta > 0, and
# -\pi < phase(z) < \pi
entire_test_set_assumptions=x \\in \\Real || y \\in \\Real || a \\in \\Real || b \\in \\Real || c \\in \\Real || r \\in \\Real || s \\in \\Real ||  t \\in \\Real || \\alpha \\in \\Real || \\beta \\in \\Real || x > 0 || \\alpha > 0 || \\beta > 0 || -\\cpi < \\phase@{z} < \\cpi

# Specifies the limit of test values generated for a single test case.
# By default, we define 10 test values for each variable. Consider an expression has 3 variables which are not limited by
# our defined constraints (global assumptions) and are not special values, then we would end up with 10^3 test calculations already just for this single test.
# Hence, it is adviced to limit the number to at least 1000. The results in our paper were created with a limit of 300.
# In our example of 10^3 test value combinations, we clip the last 700 tests.
skip_if_more_combintations=300

# Sets the timeout for each test case. Note that this time is applied for generating the test combinations and perform the
# actual numeric computations separately. In the worst case, it takes 30 seconds to generate the test combinations for all variables
# and 30 seconds to compute all of them. In reality, this never happens because building test combinations is much faster compared
# to the computation time of the numeric tests.
timeout=30

# Define the threshold for your tests (floating point value).
test_threshold=0.001

# ---------------------------------------------------------------------------------------------------------------- #
# The following values should not be changed because they are not consistently applied to Maple and Mathematica!
# ---------------------------------------------------------------------------------------------------------------- #

# The #LHS, #RHS, #RESULT and #THRESHOLD are placeholders that will be replaced at runtime buy the corresponding values.
# How you want to compare the LHS and RHS. Typical use cases are (#LHS)/(#RHS) or (#LHS)-(#RHS).
test_expression=(#LHS)-(#RHS)

# In some cases, one of the sides is 0. To handle issues with "division by zero" correctly, you should provide
# special test expressions for both cases.
test_if_rhs_null=#LHS
test_if_lhs_null=#RHS

# Define the expected outcome for each value. For example, in case of (#LHS)/(#RHS), the expected value is 1 (+/- machine accuracy).
# In case of (#LHS)/(#RHS), you would test for abs(#RESULT-1) < #THRESHOLD
test_expectation=abs(#RESULT) < #THRESHOLD

# Define the accuracy that Maple should use for evaluations (integer, high number may increase time)
test_precision=10

# ---------------------------------------------------------------------------------------------------------------- #
# The missing arguments will be automatically generated by numeric-evaluator.sh
# ---------------------------------------------------------------------------------------------------------------- #

output=./dlmf/results-generated/MapleNumeric/03-NM-numeric.txt
symbolic_results_data=./dlmf/results-original/MapleSymbolic/03-NM-symbolic.txt
